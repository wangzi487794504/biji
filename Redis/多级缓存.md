#### 多级缓存

* 传统的缓存策略一般是请求到达Tomcat后，先查询Redis，如果未命中则查询数据库，存在下面的问题:

  * 请求要经过Tomcat处理，Tomcat的性能成为整个系统的瓶颈

  * Redis缓存失效时，会对数据库产生冲击

    ![1721560922039](%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98.assets/1721560922039.png)

* 进程本地缓存

  * 缓存在日常开发中启动至关重要的作用，由于是存储在内存中，数据的读取速度是非常快的，能大量减少对数据库的访问，减少数据库的压力。我们把缓存分为两类:
    * 分布式缓存，例如Redis :
      * 优点:存储容量更大、可靠性更好、可以在集群间共享
      * 缺点:访问缓存有网络开销b
      * 场景:缓存数据量较大、可靠性要求较高、需要在集群间共享
    * 进程本地缓存，例如HashMap.Guavacache:
      * 优点:读取本地内存，没有网络开销,速度更快
      * 缺点:存储容量有限、可靠性较低、无法共享
      * 场景:性能要求较高，缓存数据量较小

* Caffeine是一个基于Java8开发的，提供了近乎最佳命中率的高性能的本地缓存库。目前Spring内部的缓存使用的就是Caffeine。GitHub地址: https://github.com/ben-manes/caffeine

  * 使用

  * 缓存策略

    ![1721562716222](%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98.assets/1721562716222.png)

    * 在默认情况下，当一个缓存元素过期的时候，Caffeine不会自动立即将其清理和驱逐。而是在一次读或写操作后，或者在空闲时间完成对失效数据的驱逐。

  * 定义缓存

    <img src="%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98.assets/1721562910443.png" alt="1721562910443" style="zoom: 67%;" />

  * 先查缓存，再查数据库（key调用）

    <img src="%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98.assets/1721562986838.png" alt="1721562986838" style="zoom:67%;" />





##### Lua语法

* lua语法不需要编译可以直接运行，直接使用lua   文件名.lua

* lua的数据类型

  ![1721563335138](%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98.assets/1721563335138.png)
  * lua声明变量时，不需要指定变量类型

    ![1721563561251](%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98.assets/1721563561251.png)

  * local说明是局部的，不加是全局的

    <img src="%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98.assets/1721564648899.png" alt="1721564648899" style="zoom:67%;" />

    * ipairs说明是要解析成键值对

  * 条件控制

    ![1721565250805](%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98.assets/1721565250805.png)

  * 与或非

    ![1721565271582](%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98.assets/1721565271582.png)





* openResty
  * OpenRestyR是一个基于Nginx的高性能Web平台，用于方便地搭建能够处理超高并发、扩展性极高的动态Web应用. Web服务和动态网关。具备下列特点:
    * 具备Nginx的完整功能
    * 基于Lua语言进行扩展，集成了大量精良的Lua库、第三方模块。
    * 允许使用Lua自定义业务逻辑、自定义库