# 类

**命名规范：**类名是以大写字母开头的名词。如果名字由多个单词组成，每个单词的第一个字母都应该大写

* 公共类的类名要和文件的名称相同，大小写需要一致
* 类的源文件中必须包含一个main方法
* 根据Java语言规范，main方法必须声明为public
  * 当main方法不是public时，有些版本的Java解释器也可以执行Java应用程序。有个程序员报告了这个bug。
* 每个Java应用程序都必须有一个main方法，其声明格式如下所示：
![](https://img2022.cnblogs.com/blog/3019006/202211/3019006-20221112191925602-277492201.png)

**注释:**在Java中，有3种标记注释的方式
* //:其注释内容从//开始到本行结尾。
* /*和*/
* /**开始，以*/结束：可以用来自动地生成文档。
###**2.数据类型：**
* 在Java中，一共有8种基本类型

  <img src="%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.assets/1700833372287.png" alt="1700833372287" style="zoom:50%;" />

* 其中有4种整型、2种浮点类型、1种用于表示Unicode编码的字符单元的字符类型char和1种用于表示真值的boolean类型。

  * 整型：int（4字节）,short（2字节）,long（8字节）,byte（1字节）
  * char（2字节）

* 在Java中，整型的范围与运行Java代码的机器无关。解决了软件从一个平台移植到另一个平台，或者在同一个平台中的不同操作系统之间进行移植给程序员带来的诸多问题

* 长整型数值有一个后缀L或l

* 十六进制数值 有一个前缀0x或0X

* 八进制有一个前缀0

* 从Java 7开始，加上前缀0b或0B就可以写二进制数。

* 从Java 7开始，还可以为数字字面量加下划线，如用1_000_00（0或0b1111_0100_0010_0100_0000）表示一百万。这些下划线只是为了让人更易读。Java编译器会去除这些下划线。

* Java没有任何无符号（unsigned）形式的int、long、short或byte类型。

  ![1701314204291](%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.assets/1701314204291.png)

  * short和char都是65536个



#### 字符编码

* 什么是字符编码
  * 字符编码是人为的定义的转换表。在字符编码中规定了一系列的文字对应的二进制。
    字符编码其实本质上就是一本字典，该字段中描述了文字与二进制之间的对照关系。
  * AsCII码采用1byte进行存储，因为英文字母是26个。(键盘上所有的键全部算上也超不过256个。1byte可以表示256种不同的情况。所以英文本身在计算机方面就占有优势。
  * ‘a’为97,‘A’为65，‘0’为48
  * 随着计算机语言的发展，后来国际标准组织制定了ISO-8859-1编码方式,又称为latin-1编码方式，向上兼容ASCII码。但不支持中文。
  * 后来发展到亚洲,才支持中文,日文,韩文.中文这块的编码方式:GB2312<GBK<GB18030(容量的关系>以上编码方式是简体中文
  * 繁体中文: big5（台湾使用的是大五码。）
  * 在java中，java语言为了支持全球所有的文字，采用了一种字符编码方式叫做unicode编码。unicode编码统一了全球所有的文字，支持所有文字。具体的实现包括:UTF-8 UTF-16 UTF-32...

#### char

* 单引号只能放一个字符
* 中文可以放，因为汉字需要两个字节,char正好
* 不能用双引号
* 第一个结论:当一个整数赋值给char类型变量的时候，会自动转换成char字符型，最终的结果是一个字符
* 第二个结论：当一个整数没有超过char的最大，都可以直接赋值



#### 转义字符

* 制表符，空格\t，换行\n,普通的一个单引号\\'，一个普通的\用\\\，unicode编码是\u，16进制如\u4e2b



#### 整数

* 整数可以十进制，十六进制(0x)，八进制(0)，二进制(0b)赋值，其中，二进制是1.8才支持
* 在任何情况下，任何整数都被当做int处理，如果当做long处理，需要添加L或l，如int a=100不存在类型转换，但long b=200存在类型转换，从int转为long
* 自动类型转换：小容量自动转换为大容量
* long=300L不存在类型转换
* int最大是2147483647
* long e=2147483648会报错，因为编译器先把2147483648看做Int类型，而int放不下，所以没有赋值就已经报错了
* 小容量不能直接赋值给大容量，必须强制类型转换，但是可能损失精度值，long转int会把二进制的前面四个字节砍掉
* byte=1按照大容量转小容量必须强转，但是这个不报错，因为java有一个特殊的语法规则，整数型字面量只要不超过byte的取值范围，都可以，不会报错，超过会报错，如byte a=128就不可以。short也有这个规则。int没有
* 在java中,int类型的运算结果还是int类型，如int temp=1/2



#### byte

* 计算机采用补码形式存储数据
* byte=-1，对应的二进制源码 10000001，反码（符号位不变，其余取反），补码是反码加一，数据都是补码的形式。byte b=(byte)150是-106

#####boolean

* 只有两个值



#####2.1浮点类型
* float(4字节),double（8字节），他们两个存储数据都是近似值
* double表示这种类型的数值精度是float类型的两倍（有人称之为双精度数值）。绝大部分应用程序都采用double类型。
* 任何一个浮点型都比long容量大
* 任何一个浮点型默认被当做double处理
* float类型的数值有一个后缀F或f（例如，3.14F）。没有后缀F的浮点数值（如3.14）默认为double类型。当然，也可以在浮点数值后面添加后缀D或d（例如，3.14D）
* 可以使用十六进制表示浮点数值。例如，0.125=2-3可以表示成0x1.0p-3。在十六进制表示法中，使用p表示指数，而不是e。
* 所有的浮点数值计算都遵循IEEE 754规范。具体来说，下面是用于表示溢出和出错情况的三个特殊的浮点数值：
  
  * 正无穷大
  
  * 负无穷大
  
  * NaN（不是一个数字） 
      * 例如，一个正整数除以0的结果为正无穷大。计算0/0或者负数的平方根结果为NaN
          *常量Double.POSITIVE_INFINITY、Double.NEGATIVE_INFINITY和Double.NaN（以及相应的Float类型的常量）分别表示这三个特殊的值，但在实际应用中很少遇到。
           ***特别要说明的是，不能这样检测一个特定值是否等于Double.NaN：因为所有的非数值的值都认为是不相等的**
      * 浮点数值不适用于无法接受舍入误差的金融计算中
* 引用数据类型：数组，类，接口，枚举，注解，记录
* 按照声明位置不同：分为成员变量（类体内）和局部变量（方法体）
* BigDeciml

####类型转换规则

* 在所有八种数据类型中，只有boolean类型不能转换，只能是true或者false。除此之外其他七种类型之间都可以进行转换。

* 如果整数型字面量没有超出byte , short,char的取值范围，可以直接将其赋值给byte , short, char类型的变量:

* **byte , short , char类型混合运算时，先各自转换成int类型再做运算**;

  ```java
    public static void main(String[] args) throws ParseException {
          char c1 = 'a';
          byte b = 1;
          System.out.println(c1 + b);
          short s = c1 + b;
      }
  此时会报错，因为编译器在静态不能知道c1 + b有多大，只能知道它是加法并且是int类型，所以会报错
  但是short s=98不会，因为编译器知道在short的取值范围里
  等号只能在运行阶段才能赋值
      int a=1;
      short  s=a;也不行，因为编译器只知道它是int类型，不能给short
  ```

  

* 小容量向大容量转换称为自动类型转换，容量从小到大的排序为:byte < short(char) <int < long < float < double，其中short和char都占用两个字节，但是char可以表示更大的正整薮:

* **多种数据类型混合运算，各自先转换成容量最大的那一种再做运算;char,short,byte除外**

* 大容量转换成小容量，称为强制类型转换，编写时必须添加强制类型转换符"，但运行时可能出现精度损失,谨慎便用:



* null不能赋值给基本数据类型，否则会报错