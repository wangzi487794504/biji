#### 语言和基础语法

* 分为编译型和解释型
* 编译型：有一个编译器解释给操作系统  c/c++
* 解释型：执行一句解释一句，java

####java

* java关键字，起名字需要避开这些，**null，true,false不是关键字，是字面量**

  <img src="%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80.assets/1689430687580.png" alt="1689430687580" style="zoom:80%;" />

* 标识符：java所有的组成部分都需要起名字。类名、变量名以及方法名都被称为标识符。

  * 组成：字母，数字，下划线

  * 需要避开关键字

  * 开头必须以**字母A-Z或a-z（不是字符）**，美元符号$，或者下划线

  * 开头之后可以由**字符**，美元，下划线，数字的任意组合

  * ==可以使用中文，不建议==

  * 大小写敏感

  * 理论没有长度限制

    

* 数据类型

  * java为强类型语言，所有变量必须先定义后使用
  * 分类：基本类型和引用类型
    * 基本类型：数值类型：（整数int short  long byte(1)、浮点float double 、字符 char(2)）、布尔类型boolean(1位)
    * 使用long要在数字后面加L
    * 使用float要在数字后面加F
    * ==考点：String既不是基本数据类型，也不是关键词==
  * 进制：二进制0b，八进制0，十六进制0x
  * float和double并不能精确表示小数，不能应用于银行业务，使用BigDecimal类
  * 字符范围u0000-uffff，字符的本质是数字，如char c3=‘\u0061’为a
  * 转义字符（很多）
    * \t  制表符
    * \n 换行符

* 强制转换

  * 小数优先级大于整数
  
* 转换小心内存溢出，int i=128;byte a=(byte) i;//强制转换造成内存溢出
  
  * ==不能对布尔进行转换==
  
* 只有高容量到低容量采用强制类型转换
  
* 不能转换到不相关的类型
  
* 注意事项

  * 操作比较大的数，注意溢出问题
  * jdk7以后，数字之间可以用下划线分割，方便读  100000=100_000
  
* **精度丢失是指大的范围到小的范围转换**

* **基本数据类型byte 、short、char------>int----->long------>float------>double特别的: byte、 short、char类型的变量之间做运算，结果为int类型。**

  ```java
  byte b1=1,b2=2,b3,b6; 
  
  final byte b4=4,b5=6; 
  
  b6=b4+b5; 
  
  b3=(b1+b2); 
  
  System.out.println(b3+b6);
  被final修饰的变量是常量，这里的b6=b4+b5可以看成是b6=10；在编译时就已经变为b6=10了
  
  而b1和b2是byte类型，java中进行计算时候将他们提升为int类型，再进行计算，b1+b2计算后已经是int类型，赋值给b3，b3是byte类型，类型不匹配，编译不会通过，需要进行强制转换。
      b3=b1+b2编译出错
      
     在b3=b1+b2中，b1,b2是byte型，java中进行计算时需要将他们提升为int类型，再进行计算，b1+b2计算后已经是int类型，赋值给b3，b3是byte类型，类型不匹配，若没有强转，那么编译就不会通过，因为int类型不能直接赋值给byte类型，如若需要，则需要强转。
  
  但b6同样被两个byte赋值了，为什么它不报错？
  
  ----------原因就在于final，被final修饰的变量是一个常量，在这里b4可以替换成3，b5可以替换成4。即：b6=4+5；不涉及类型提升，在编译时就已经变成了b6=9
  
      除了自增加自减不进行转化外，其它情况都是无long型时，所有非int类型转成int类型；有long类型时，都转成long类型
      当两个操作数中没有long类型时，两个操作数中非int类型会先自动转换为int类型，再参与运算，返回结果为int；
  
  当两个操作数中含有long类型时，两个操作数中非long类型会自动转换为long类型，再参与运算，返回结果为long；
  ```

  

