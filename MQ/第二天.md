####RocketMQ快速入门

* RocketMQ提供了发送多种发送消息的模式，例如同步消息，异步消息，顺序消息，延迟消息，事务消息等，我们一一学习

#####8.1 消息发送和监听的流程

* 我们先搞清楚消息发送和监听的流程，然后我们在开始敲代码

######8.1.1 消息生产者

* 1.创建消息生产者producer，并制定生产者组名  、
* 2.指定Nameserver地址
* 3.启动producer
* 4.创建消息对象，指定主题Topic、Tag和消息体等
* 5.发送消息
*  6.关闭生产者producer 



######8.1.2 消息消费者

* 1.创建消费者consumer，制定消费者组名 
* 2.指定Nameserver地址
* 3.创建监听订阅主题Topic和Tag等
* 4.处理消息 
* 5.启动消费者consumer  

 

#####8.2 搭建Rocketmq-demo

######8.2.1 加入依赖

```xml
<dependencies>
    <dependency>
        <groupId>org.apache.rocketmq</groupId>
        <artifactId>rocketmq-client</artifactId>
        <version>4.9.2</version>
        <!--docker的用下面这个版本-->
		<version>4.4.0</version>
    </dependency>
    <dependency>
        <groupId>junit</groupId>
        <artifactId>junit</artifactId>
        <version>4.12</version>
    </dependency>
    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <version>1.18.22</version>
    </dependency>
</dependencies>

```



######8.2.2 编写生产者

```java
@Test
public void testProducer() throws Exception {
    // 创建默认的生产者
    DefaultMQProducer producer = new DefaultMQProducer("test-group");
    // 设置nameServer地址
    producer.setNamesrvAddr("localhost:9876");
    // 启动实例
    producer.start();
    for (int i = 0; i < 10; i++) {
        // 创建消息
        // 第一个参数：主题的名字
        // 第二个参数：消息内容
        Message msg = new Message("TopicTest", ("Hello RocketMQ " + i).getBytes());
        SendResult send = producer.send(msg);
        System.out.println(send);
    }
    // 关闭实例
    producer.shutdown();
}

```

### 8.2.3 编写消费者

```java
    @Test
    public void testConsumer() throws Exception {
        // 创建默认消费者组
        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer("consumer-group");
        // 设置nameServer地址
        consumer.setNamesrvAddr("localhost:9876");
        // 订阅一个主题来消费   *表示没有过滤参数 表示这个主题的任何消息
        consumer.subscribe("TopicTest", "*");
        // 注册一个消费监听 MessageListenerConcurrently 是多线程消费，默认20个线程，可以参看consumer.setConsumeThreadMax()
        consumer.registerMessageListener(new MessageListenerConcurrently() {
            @Override
            public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs,
                                                            ConsumeConcurrentlyContext context) {
                System.out.println(Thread.currentThread().getName() + "----" + msgs);
                // 返回消费的状态 如果是CONSUME_SUCCESS 则成功，若为RECONSUME_LATER则该条消息会被重回队列，重新被投递
                // 重试的时间为messageDelayLevel = "1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h
                // 也就是第一次1s 第二次5s 第三次10s  ....  如果重试了18次 那么这个消息就会被终止发送给消费者
//                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
                return ConsumeConcurrentlyStatus.RECONSUME_LATER;
            }
        });
        // 这个start一定要写在registerMessageListener下面
        consumer.start();
        System.in.read();
    }

```

######8.2.4 测试

* 启动生产者和消费者进行测试





####9. 消费模式

* MQ的消费模式可以大致分为两种，一种是推Push，一种是拉Pull。
  * Push是服务端【MQ】主动推送消息给客户端，优点是及时性较好，但如果客户端没有做好流控，一旦服务端推送大量消息到客户端时，就会导致客户端消息堆积甚至崩溃。
  * Pull是客户端需要主动到服务端取数据，优点是客户端可以依据自己的消费能力进行消费，但拉取的频率也需要用户自己控制，拉取频繁容易造成服务端和客户端的压力，拉取间隔长又容易造成消费不及时。
  * Push模式也是基于pull模式的，只能客户端内部封装了api，一般场景下，上游消息生产量小或者均速的时候，选择push模式。在特殊场景下，例如电商大促，抢优惠券等场景可以选择pull模式

####10.  RocketMQ发送同步消息

* 上面的快速入门就是发送同步消息，发送过后会有一个返回值，也就是mq服务器接收到消息后返回的一个确认，这种方式非常安全，但是性能上并没有这么高，而且在mq集群中，也是要等到所有的从机都复制了消息以后才会返回，所以针对重要的消息可以选择这种方式

  ![img](%E7%AC%AC%E4%BA%8C%E5%A4%A9.assets/clip_image042.jpg)

####11.  RocketMQ发送异步消息

* 异步消息通常用在对响应时间敏感的业务场景，即发送端不能容忍长时间地等待Broker的响应。发送完以后会有一个异步消息通知

#####11.1 异步消息生产者

```java
@Test
public void testAsyncProducer() throws Exception {
    // 创建默认的生产者
    DefaultMQProducer producer = new DefaultMQProducer("test-group");
    // 设置nameServer地址
    producer.setNamesrvAddr("localhost:9876");
    // 启动实例
    producer.start();
    Message msg = new Message("TopicTest", ("异步消息").getBytes());
    producer.send(msg, new SendCallback() {
        @Override
        public void onSuccess(SendResult sendResult) {
            System.out.println("发送成功");
        }
        @Override
        public void onException(Throwable e) {
            System.out.println("发送失败");
        }
    });
    System.out.println("看看谁先执行");
    // 挂起jvm 因为回调是异步的不然测试不出来
    System.in.read();
    // 关闭实例
    producer.shutdown();
}

```

#####11.2 异步消息消费者

```java
@Test
public void testAsyncConsumer() throws Exception {
    // 创建默认消费者组
    DefaultMQPushConsumer consumer = new DefaultMQPushConsumer("consumer-group");
    // 设置nameServer地址
    consumer.setNamesrvAddr("localhost:9876");
    // 订阅一个主题来消费   *表示没有过滤参数 表示这个主题的任何消息
    consumer.subscribe("TopicTest", "*");
    // 注册一个消费监听 MessageListenerConcurrently是并发消费
    // 默认是20个线程一起消费，可以参看 consumer.setConsumeThreadMax()
    consumer.registerMessageListener(new MessageListenerConcurrently() {
        @Override
        public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs,
                                                        ConsumeConcurrentlyContext context) {
            // 这里执行消费的代码 默认是多线程消费
            System.out.println(Thread.currentThread().getName() + "----" + msgs);
            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
        }
    });
    consumer.start();
    System.in.read();
}

```

* 消费者组应该保证同一个组订阅的消息一致，负责会出现消息丢失等问题

* 多个组订阅一个，每个组都给一份

* 每个组的消费者是按照队列分的，队列不够那最后分不到的就永远没有消息（新版本到消息粒度）

  <img src="%E7%AC%AC%E4%BA%8C%E5%A4%A9.assets/1724423563488.png" alt="1724423563488" style="zoom:50%;" />

####12.  RocketMQ发送单向消息

这种方式主要用在不关心发送结果的场景，这种方式吞吐量很大，但是存在消息丢失的风险，例如日志信息的发送

#####12.1 单向消息生产者

```
@Test
public void testOnewayProducer() throws Exception {
    // 创建默认的生产者
    DefaultMQProducer producer = new DefaultMQProducer("test-group");
    // 设置nameServer地址
    producer.setNamesrvAddr("localhost:9876");
    // 启动实例
    producer.start();
    Message msg = new Message("TopicTest", ("单向消息").getBytes());
    // 发送单向消息
    producer.sendOneway(msg);
    // 关闭实例
    producer.shutdown();
}

```

#####12.2 单向消息消费者

消费者和上面一样

####13.  RocketMQ发送延迟消息

* 消息放入mq后，过一段时间，才会被监听到，然后消费

* 比如下订单业务，提交了一个订单就可以发送一个延时消息，30min后去检查这个订单的状态，如果还是未付款就取消订单释放库存。

  

#####13.1 延迟消息生产者

```java
@Test
public void testDelayProducer() throws Exception {
    // 创建默认的生产者
    DefaultMQProducer producer = new DefaultMQProducer("test-group");
    // 设置nameServer地址
    producer.setNamesrvAddr("localhost:9876");
    // 启动实例
    producer.start();
    Message msg = new Message("TopicTest", ("延迟消息").getBytes());
    // 给这个消息设定一个延迟等级
    // messageDelayLevel = "1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h
    msg.setDelayTimeLevel(3);
    // 发送单向消息
    producer.send(msg);
    // 打印时间
    System.out.println(new Date());
    // 关闭实例
    producer.shutdown();
}

```

## 13.2 延迟消息消费者

消费者和上面一样

这里注意的是RocketMQ不支持任意时间的延时

只支持以下几个固定的延时等级，等级1就对应1s，以此类推，最高支持2h延迟

private String messageDelayLevel = "1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h";

# 14.  RocketMQ发送顺序消息

消息有序指的是可以**按照消息的发送顺序来消费**(FIFO)。RocketMQ可以严格的保证消息有序，可以分为：分区有序或者全局有序。

可能大家会有疑问，mq不就是FIFO吗？

rocketMq的broker的机制，导致了rocketMq会有这个问题

因为一个broker中对应了四个queue

![img](%E7%AC%AC%E4%BA%8C%E5%A4%A9.assets/clip_image044.jpg)

顺序消费的原理解析，在默认的情况下消息发送会采取Round Robin轮询方式把消息发送到不同的queue(分区队列)；而消费消息的时候从多个queue上拉取消息，这种情况发送和消费是不能保证顺序。但是如果控制发送的顺序消息只依次发送到同一个queue中，消费的时候只从这个queue上依次拉取，则就保证了顺序。当发送和消费参与的queue只有一个，则是全局有序；如果多个queue参与，则为分区有序，即相对每个queue，消息都是有序的。

下面用订单进行分区有序的示例。一个订单的顺序流程是：下订单、发短信通知、物流、签收。订单顺序号相同的消息会被先后发送到同一个队列中，消费时，同一个顺序获取到的肯定是同一个队列。

## 14.1 场景分析

模拟一个订单的发送流程，创建两个订单，发送的消息分别是

订单号111 消息流程 下订单->物流->签收

订单号112 消息流程 下订单->物流->拒收

## 14.2 创建一个订单对象

```

```

 

## 14.3 顺序消息生产者

```

```

## 14.4 顺序消息消费者，测试时等一会即可有延迟

```

```

# 15.  RocketMQ发送批量消息

Rocketmq可以一次性发送一组消息，那么这一组消息会被当做一个消息消费

## 15.1 批量消息生产者

```

```

## 15.2 批量消息消费者

```

```

# 16.  RocketMQ发送事务消息

## 16.1 事务消息的发送流程

它可以被认为是一个两阶段的提交消息实现，以确保分布式系统的最终一致性。事务性消息确保本地事务的执行和消息的发送可以原子地执行。

![img](%E7%AC%AC%E4%BA%8C%E5%A4%A9.assets/clip_image046.jpg)

![img](%E7%AC%AC%E4%BA%8C%E5%A4%A9.assets/clip_image048.jpg)

上图说明了事务消息的大致方案，其中分为两个流程：正常事务消息的发送及提交、事务消息的补偿流程。

**事务消息发送及提交**

\1. 发送消息（half消息）。

\2. 服务端响应消息写入结果。

\3. 根据发送结果执行本地事务（如果写入失败，此时half消息对业务不可见，本地逻辑不执行）。

\4. 根据本地事务状态执行Commit或Rollback（Commit操作生成消息索引，消息对消费者可见）

**事务补偿**

\1. 对没有Commit/Rollback的事务消息（pending状态的消息），从服务端发起一次“回查”

\2. Producer收到回查消息，检查回查消息对应的本地事务的状态

\3. 根据本地事务状态，重新Commit或者Rollback

其中，补偿阶段用于解决消息UNKNOW或者Rollback发生超时或者失败的情况。

**事务消息状态**

事务消息共有三种状态，提交状态、回滚状态、中间状态：

l TransactionStatus.CommitTransaction: 提交事务，它允许消费者消费此消息。

l TransactionStatus.RollbackTransaction: 回滚事务，它代表该消息将被删除，不允许被消费。

l TransactionStatus.Unknown: 中间状态，它代表需要检查消息队列来确定状态。

## 16.2 事务消息生产者

```

```

## 16.3 事务消息消费者

```

```

## 16.4 测试结果

 

![img](%E7%AC%AC%E4%BA%8C%E5%A4%A9.assets/clip_image050.jpg)

# 17.  RocketMQ发送带标签的消息，消息过滤

Rocketmq提供消息过滤功能，通过tag或者key进行区分

我们往一个主题里面发送消息的时候，根据业务逻辑，可能需要区分，比如带有tagA标签的被A消费，带有tagB标签的被B消费，还有在事务监听的类里面，只要是事务消息都要走同一个监听，我们也需要通过过滤才区别对待

## 17.1 标签消息生产者

```

```

## 17.2 标签消息消费者

```

```

## 17.3 什么时候该用 Topic，什么时候该用 Tag？

总结：不同的业务应该使用不同的Topic如果是相同的业务里面有不同表的表现形式，那么我们要使用tag进行区分

可以从以下几个方面进行判断：

1.消息类型是否一致：如普通消息、事务消息、定时（延时）消息、顺序消息，不同的消息类型使用不同的 Topic，无法通过 Tag 进行区分。

2.业务是否相关联：没有直接关联的消息，如淘宝交易消息，京东物流消息使用不同的 Topic 进行区分；而同样是天猫交易消息，电器类订单、女装类订单、化妆品类订单的消息可以用 Tag 进行区分。

3.消息优先级是否一致：如同样是物流消息，盒马必须小时内送达，天猫超市 24 小时内送达，淘宝物流则相对会慢一些，不同优先级的消息用不同的 Topic 进行区分。

4.消息量级是否相当：有些业务消息虽然量小但是实时性要求高，如果跟某些万亿量级的消息使用同一个 Topic，则有可能会因为过长的等待时间而“饿死”，此时需要将不同量级的消息进行拆分，使用不同的 Topic。

**总的来说，针对消息分类，您可以选择创建多个 Topic****，或者在同一个 Topic** **下创建多个 Tag****。但通常情况下，不同的 Topic** **之间的消息没有必然的联系，而 Tag** **则用来区分同一个 Topic** **下相互关联的消息，例如全集和子集的关系、流程先后的关系。**

# 18.  RocketMQ中消息的Key

在rocketmq中的消息，默认会有一个messageId当做消息的唯一标识，我们也可以给消息携带一个key，用作唯一标识或者业务标识，包括在控制面板查询的时候也可以使用messageId或者key来进行查询

![img](%E7%AC%AC%E4%BA%8C%E5%A4%A9.assets/clip_image052.jpg)

## 18.1 带key消息生产者

```

```

## 18.2 带key消息消费者

```

```

![img](%E7%AC%AC%E4%BA%8C%E5%A4%A9.assets/clip_image054.jpg)

 

# 19.  RocketMQ重试机制

## 19.1 生产者重试

// 失败的情况重发3次

producer.setRetryTimesWhenSendFailed(3);

// 消息在1S内没有发送成功，就会重试

producer.send(msg, 1000);

## 19.2 消费者重试

在消费者放return ConsumeConcurrentlyStatus.RECONSUME_LATER;后就会执行重试

上图代码中说明了，我们再实际生产过程中，一般重试3-5次，如果还没有消费成功，则可以把消息签收了，通知人工等处理

```

```

# 20.  RocketMQ死信消息

当消费重试到达阈值以后，消息不会被投递给消费者了，而是进入了死信队列

当一条消息初次消费失败，RocketMQ会自动进行消息重试，达到最大重试次数后，若消费依然失败，则表明消费者在正常情况下无法正确地消费该消息。此时，该消息不会立刻被丢弃，而是将其发送到该消费者对应的特殊队列中，这类消息称为死信消息（Dead-Letter Message），存储死信消息的特殊队列称为死信队列（Dead-Letter Queue），死信队列是死信Topic下分区数唯一的单独队列。如果产生了死信消息，那对应的ConsumerGroup的死信Topic名称为%DLQ%ConsumerGroupName，死信队列的消息将不会再被消费。可以利用RocketMQ Admin工具或者RocketMQ Dashboard上查询到对应死信消息的信息。我们也可以去监听死信队列，然后进行自己的业务上的逻辑

## 20.1 消息生产者

```

```

## 20.2 消息消费者

```

```

## 20.3 死信消费者 

注意权限问题

![img](%E7%AC%AC%E4%BA%8C%E5%A4%A9.assets/clip_image056.jpg)

```

```

## 20.4 控制台显示

![img](%E7%AC%AC%E4%BA%8C%E5%A4%A9.assets/clip_image058.jpg)

![img](%E7%AC%AC%E4%BA%8C%E5%A4%A9.assets/clip_image060.jpg)

# 21.  RocketMQ消息重复消费问题

## 21.1 为什么会出现重复消费问题呢？

BROADCASTING(广播)模式下，所有注册的消费者都会消费，而这些消费者通常是集群部署的一个个微服务，这样就会多台机器重复消费，当然这个是根据需要来选择。

CLUSTERING（负载均衡）模式下，如果一个topic被多个consumerGroup消费，也会重复消费。

即使是在CLUSTERING模式下，同一个consumerGroup下，一个队列只会分配给一个消费者，看起来好像是不会重复消费。但是，有个特殊情况：一个消费者新上线后，同组的所有消费者要重新负载均衡（反之一个消费者掉线后，也一样）。一个队列所对应的新的消费者要获取之前消费的offset（偏移量，也就是消息消费的点位），此时之前的消费者可能已经消费了一条消息，但是并没有把offset提交给broker，那么新的消费者可能会重新消费一次。虽然orderly模式是前一个消费者先解锁，后一个消费者加锁再消费的模式，比起concurrently要严格了，但是加锁的线程和提交offset的线程不是同一个，所以还是会出现极端情况下的重复消费。

还有在发送批量消息的时候，会被当做一条消息进行处理，那么如果批量消息中有一条业务处理成功，其他失败了，还是会被重新消费一次。

**那么如果在CLUSTERING****（负载均衡）模式下，并且在同一个消费者组中，不希望一条消息被重复消费，改怎么办呢？我们可以想到去重操作，找到消息唯一的标识，可以是msgId****也可以是你自定义的唯一的key****，这样就可以去重了**

## 21.2 解决方案

使用去重方案解决，例如将消息的唯一标识存起来，然后每次消费之前先判断是否存在这个唯一标识，如果存在则不消费，如果不存在则消费，并且消费以后将这个标记保存。

想法很好，但是消息的体量是非常大的，可能在生产环境中会到达上千万甚至上亿条，那么我们该如何选择一个容器来保存所有消息的标识，并且又可以快速的判断是否存在呢？

我们可以选择布隆过滤器(BloomFilter)

**布隆过滤器（Bloom Filter****）是1970****年由布隆提出的。它实际上是一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都比一般的算法要好的多，缺点是有一定的误识别率和删除困难。**

**在hutool****的工具中我们可以直接使用，当然你自己使用redis****的bitmap****类型手写一个也是可以的 [https://hutool.cn/docs/#/bloomFilter/%E6%A6%82%E8%BF%B0](https://hutool.cn/docs/#/bloomFilter/概述)** 

![img](%E7%AC%AC%E4%BA%8C%E5%A4%A9.assets/clip_image062.jpg)

## 21.3 测试生产者

```

```

## 21.4 添加hutool的依赖

```

```

## 21.5 测试消费者

```

```

# 22.  Rocketmq集成SpringBoot

## 22.1 搭建rocketmq-producer（消息生产者）

![img](%E7%AC%AC%E4%BA%8C%E5%A4%A9.assets/clip_image064.jpg)

![img](%E7%AC%AC%E4%BA%8C%E5%A4%A9.assets/clip_image066.jpg)

### 22.1.1 创建项目，完整的pom.xml

```

```

### 22.1.2 修改配置文件application.yml

```

```

### 22.1.3 我们在测试类里面测试发送消息

往powernode主题里面发送一个简单的字符串消息

```

```

运行后查看控制台

![img](%E7%AC%AC%E4%BA%8C%E5%A4%A9.assets/clip_image068.jpg)

### 22.1.4 查看rocketMq的控制台

![img](%E7%AC%AC%E4%BA%8C%E5%A4%A9.assets/clip_image070.jpg)

查看消息细节

![img](%E7%AC%AC%E4%BA%8C%E5%A4%A9.assets/clip_image072.jpg)

## 22.2 搭建rocketmq-consumer（消息消费者）

![img](%E7%AC%AC%E4%BA%8C%E5%A4%A9.assets/clip_image074.jpg)

![img](%E7%AC%AC%E4%BA%8C%E5%A4%A9.assets/clip_image076.jpg)

### 22.2.1 创建项目，完整的pom.xml

```

```

### 22.2.2 修改配置文件application.yml

```

```

### 22.2.3 添加一个监听的类SimpleMsgListener

消费者要消费消息，就添加一个监听

```

```

### 22.2.4 启动rocketmq-consumer

查看控制台，发现我们已经监听到消息了

![img](%E7%AC%AC%E4%BA%8C%E5%A4%A9.assets/clip_image078.jpg)

# 23.  RocketMQ发送对象消息和集合消息

我们接着在上面项目里面做

## 23.1 发送对象消息

主要是监听的时候泛型中写对象的类型即可

### 23.1.1 修改rocketmq-producer添加一个Order类

```

```

### 23.1.2 修改rocketmq-producer添加一个单元测试

```

```

### 23.1.3 发送此消息

### 23.1.4 修改rocketmq-consumer也添加一个Order类（拷贝过来）

### 23.1.5 修改rocketmq-consumer添加一个ObjMsgListener

```

```

### 23.1.6 重启rocketmq-consumer后查看控制台

对象消息已经监听到了

![img](%E7%AC%AC%E4%BA%8C%E5%A4%A9.assets/clip_image080.jpg)

## 23.2 发送集合消息

和对象消息同理，创建一个Order的集合，发送出去，监听方注意修改泛型中的类型为Object即可，这里就不做重复演示了

![img](%E7%AC%AC%E4%BA%8C%E5%A4%A9.assets/clip_image082.jpg)

# 24.  RocketMQ集成SpringBoot发送不同消息模式

## 24.1 发送同步消息

理解为：消息由消费者发送到broker后，会得到一个确认，是具有可靠性的

这种可靠性同步地发送方式使用的比较广泛，比如：重要的消息通知，短信通知等。

我们在上面的快速入门中演示的消息，就是同步消息，即

rocketMQTemplate.syncSend()

rocketMQTemplate.send()

rocketMQTemplate.convertAndSend()

这三种发送消息的方法，底层都是调用syncSend，发送的是同步消息

## 24.2 发送异步消息

rocketMQTemplate.asyncSend()

### 24.2.1 修改rocketmq-producer添加一个单元测试

```

```

### 24.2.2 运行查看控制台效果

谁先发送打印在前面

![img](%E7%AC%AC%E4%BA%8C%E5%A4%A9.assets/clip_image084.jpg)

## 24.3 发送单向消息

这种方式主要用在不关心发送结果的场景，这种方式吞吐量很大，但是存在消息丢失的风险，例如日志信息的发送

### 24.3.1 修改rocketmq-producer添加一个单元测试

```

```

## 24.4 发送延迟消息

### 24.4.1 修改rocketmq-producer添加一个单元测试

```

```

### 24.4.2 运行后，查看消费者端，过了30s才被消费

这里注意的是RocketMQ不支持任意时间的延时

只支持以下几个固定的延时等级，等级1就对应1s，以此类推，最高支持2h延迟

private String messageDelayLevel = "1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h";

## 24.5 发送顺序消息

### 24.5.1 修改Order表添加一个顺序字段

```

```

### 24.5.2 修改rocketmq-producer添加一个单元测试

```

```

### 24.5.3 发送消息

### 24.5.4 修改rocketmq-consumer的ObjMsgListener

```

```

### 24.5.5 重启rocketmq-consumer

查看控制台，消息按照我们的放入顺序进行消费了

![img](%E7%AC%AC%E4%BA%8C%E5%A4%A9.assets/clip_image086.jpg)

## 24.6 发送事务消息

### 24.6.1 修改rocketmq-producer添加一个单元测试

```

```

### 24.6.2 修改rocketmq-producer添加一个本地事务消息的监听（半消息）

```

```

### 24.6.3 测试发送事务，建议断点启动

\1. 消息会先到事务监听类的执行方法，

\2. 如果返回状态为COMMIT，则消费者可以直接监听到

\3. 如果返回状态为ROLLBACK，则消息发送失败，直接回滚

\4. 如果返回状态为UNKNOW，则过一会会走回查方法

\5. 如果回查方法返回状态为UNKNOW或者ROLLBACK，则消息发送失败，直接回滚

\6. 如果回查方法返回状态为COMMIT，则消费者可以直接监听到

# 25.  RocketMQ集成SpringBoot的消息过滤

## 25.1 tag过滤（常在消费者端过滤）

我们从源码注释得知，tag带在主题后面用：来携带，感谢注释

![img](%E7%AC%AC%E4%BA%8C%E5%A4%A9.assets/clip_image088.jpg)

我们往下去看源码，在 

org.apache.rocketmq.spring.support.RocketMQUtil 的getAndWrapMessage方法里面看到了具体细节，我们也知道了keys在消息头里面携带

![img](%E7%AC%AC%E4%BA%8C%E5%A4%A9.assets/clip_image090.jpg)

### 25.1.1 修改rocketmq-producer添加一个单元测试

```

```

### 25.1.2 发送消息

### 25.1.3 修改rocketmq-consumer添加一个TagMsgListener

```

```

### 25.1.4 重启rocketmq-consumer查看控制台

![img](%E7%AC%AC%E4%BA%8C%E5%A4%A9.assets/clip_image092.jpg)

## 25.2 Key过滤（可以在事务监听的类里面区分）

### 25.2.1 修改rocketmq-producer添加一个单元测试

```

```

### 25.2.2 断点发送这个消息，查看事务里面消息头

![img](%E7%AC%AC%E4%BA%8C%E5%A4%A9.assets/clip_image094.jpg)

我们在mq的控制台也可以看到

![img](%E7%AC%AC%E4%BA%8C%E5%A4%A9.assets/clip_image096.jpg)

# 26.  RocketMQ集成SpringBoot消息消费两种模式

Rocketmq消息消费的模式分为两种：**负载均衡模式和广播模式**

负载均衡模式表示多个消费者交替消费同一个主题里面的消息

广播模式表示每个每个消费者都消费一遍订阅的主题的消息

## 26.1 再搭建一个消费者rocketmq-consumer-b，依赖和配置文件和rocketmq-consumer一致，记住端口修改一下，避免占用

## 26.2 rocketmq-consumer-b添加一个监听

```

```

## 26.3 修改rocketmq-consumer的SimpleMsgListener

```

```

## 26.4 启动两个消费者

## 26.5 在生产者里面添加一个单元测试并且运行

```

```

## 26.6 查看两个消费者的控制台，发现是负载均衡的模式

![img](%E7%AC%AC%E4%BA%8C%E5%A4%A9.assets/clip_image098.jpg)

![img](%E7%AC%AC%E4%BA%8C%E5%A4%A9.assets/clip_image100.jpg)

## 26.7 修改两个消费者的模式为BROADCASTING

重启测试，结果是广播模式，每个消费者都消费了这些消息

 

项目中 一般部署多态机器 消费者 2 - 3  根据业务可以选择具体的模式来配置

 

**重置消费点位,** **将一个组的消费节点** **设置在之前的某一个时间点上去** **从这个时间点开始往后消费**

 

**跳过堆积** **选择一个组** **跳过堆积以后** **这个组里面的的所有都不会被消费了**

# 27.  如何解决消息堆积问题？

 一般认为单条队列消息差值>=10w时 算堆积问题

## 27.1 什么情况下会出现堆积

\1. 生产太快了 

生产方可以做业务限流

增加消费者数量,但是消费者数量<=队列数量,适当的设置最大的消费线程数量(根据IO(2n)/CPU(n+1))

动态扩容队列数量,从而增加消费者数量

\2. 消费者消费出现问题

排查消费者程序的问题

# 28.  如何确保消息不丢失？

\1. 生产者使用同步发送模式 ，收到mq的返回确认以后 顺便往自己的数据库里面写

msgId status(0) time

\2. 消费者消费以后 修改数据这条消息的状态 = 1

\3. 写一个定时任务 间隔两天去查询数据 如果有status = 0 and time < day-2

\4. 将mq的刷盘机制设置为同步刷盘

\5. 使用集群模式 ，搞主备模式，将消息持久化在不同的硬件上

\6. 可以开启mq的trace机制，消息跟踪机制

 

1.在broker.conf中开启消息追踪

traceTopicEnable=true

2.重启broker即可

3.生产者配置文件开启消息轨迹

enable-msg-trace: true

\4. 消费者开启消息轨迹功能，可以给单独的某一个消费者开启

enableMsgTrace = true

 

 

在rocketmq的面板中可以查看消息轨迹

默认会将消息轨迹的数据存在 RMQ_SYS_TRACE_TOPIC 主题里面

# 29.  安全

\1. 开启acl的控制 在broker.conf中开启aclEnable=true

\2. 配置账号密码 修改plain_acl.yml 

\3. 修改控制面板的配置文件 放开52/53行 把49行改为true 上传到服务器的jar包平级目录下即可