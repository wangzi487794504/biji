##### 视图

* 只能将select创建为视图， 视图是一个虚拟的表，是一个表中的数据经过某种筛选后的显示方式，视图由一个预定义的查询select语句组成。 

* 在 SQL 中，视图是基于 SQL 语句的结果集的可视化的表。视图包含行和列，就像一个真实的表。视图中的字段就是来自一个或多个数据库中的真实的表中的字段。我们可以向视图添加 SQL 函数、WHERE 以及 JOIN 语句，我们也可以提交数据，就像这些来自于某个单一的表。

  * 注释：数据库的设计和结构不会受到视图中的函数、where 或 join 语句的影响。

* 视图作用

  1. 如果开发中有一条非常复杂的SQL，而这个SQL在多处使用，会给开发和维护带来成本。使用视图可以降低开发和维护的成本。
  2. 视图可以隐藏表的字段名。

* 创建视图

  * 对视图进行增删改，原表数据会受到影响

    ```sql
    create or replace view v_emp as select e.ename,d.dname from emp e join dept d on e.deptno = d.deptno;
    ```

* 修改视图

  ```sql
  alter view v_emp as select e.ename,d.dname,d.deptno from emp e join dept d on e.deptno = d.deptno;
  ```

* 删除视图

  ```sql
  drop view if exists v_emp;
  ```

* 对视图增删改（DML：insert delete update）可以影响到原表数据。




##### 事务

* 事务是一个最小的工作单元。在数据库当中，事务表示一件完整的事儿。

* 一个业务的完成可能需要多条DML语句共同配合才能完成，例如转账业务，需要执行两条DML语句，先更新张三账户的余额，再更新李四账户的余额，为了保证转账业务不出现问题，就必须保证要么同时成功，要么同时失败，怎么保证同时成功或者同时失败呢？就需要使用事务机制。

* 也就是说用了事务机制之后，在同一个事务当中，多条DML语句会同时成功，或者同时失败，不会出现一部分成功，一部分失败的现象。

* 事务只针对DML语句有效：因为只有这三个语句是改变表中数据的。

  1. insert
  2. delete
  3. update

* 事务的四大特性ACID

  * 原子性（Atomicity）：是指事务包含的所有操作要么全部成功，要么同时失败。
  * 一致性（Consistency）：是指事务开始前，和事务完成后，数据应该是一致的。例如张三和李四的钱加起来是5000，中间不管进行过多少次的转账操作(update)，总量5000是不会变的。这就是事务的一致性。
  * 隔离性（Isolation）：隔离性是当多个⽤户并发访问数据库时，⽐如操作同⼀张表时，数据库为每⼀个⽤户开启的事务，不能被其他事务的操作所⼲扰，多个并发事务之间要相互隔离。
  * 持久性（Durability）：持久性是指⼀个事务⼀旦被提交了，那么对数据库中的数据的改变就是永久性的，==即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。==

* 事务的使用

  * 在dos命令窗口中开启MySQL事务命令：start transaction; 或者：begin;
  * 回滚事务命令：rollback; 
  * 提交事务命令：commit;
  * 只要执行以上的rollback或者commit，事务都会结束。
  * MySQL默认情况下采用的事务机制是：自动提交。所谓自动提交就是只要执行一条DML语句则提交一次。

* 事务的隔离级别

  * **隔离级别从低到高排序：读未提交 < 读提交 < 可重复读 < 串行化**

  * **不同隔离级别会存在不同的现象，现象按照严重性从高到低排序：脏读 > 不可重复读 > 幻读**

    ![image.png](%E8%A7%86%E5%9B%BE%E5%92%8C%E4%BA%8B%E5%8A%A1.assets/image.png)

  
  * oracle默认的隔离级别时读提交，mysql默认的是可重复读
    * 查看隔离级别的命令
      * 查看当前会话的隔离级别：select @@transaction_isolation;
      * 查看全局的隔离级别：select @@gobal.transaction_isolation;
    * 设置事务隔离级别：

      - 会话级：set session transaction isolation level read committed;
      - 全局级：set global transaction isolation level read committed;
  * 脏读：指的是一个事务读取了另一个事务尚未提交的数据，即读取了另一个事务中的脏数据（Dirty Data）。在此情况下，如果另一个事务回滚了或者修改了这些数据，那么读取这些脏数据的事务所处理的数据就是不准确的。
  * 不可重复读：指在一个事务内，多次读取同一个数据行，得到的结果可能是不一样的。这是由于其他事务对数据行做出了修改操作，导致数据的不一致性。**就是另外一个事务提交了修改，你这个事务没有结束，在你这个事务中假定你有读取两次的操作，结果第一次和第二次的结果不一样，第二次读取到了另外一个事务修改后的结果**
  * 幻读：指在事务执行过程中，前后两次相同的查询条件得到的结果集不一致，可能会变多或变少。
    * 针对**快照读**（普通 select 语句），是**通过 MVCC 方式解决了幻读**，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好的避免了幻读问题。
    * 针对**当前读**（select ... for update    DML等语句），是**通过 next-key lock（记录锁+间隙锁）方式解决了幻读**，因为当执行 select ... for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好的避免了幻读问题。
      * 记录锁防止删除，间隙锁防止插入
    * ==在可重复读的条件下防止幻读，要么都使用当前读（用锁锁住了），要么都是用快照读。（但是会引入新的问题，两次快照读之间执行力插入语句就会出现问题（DML），所以不是特别靠谱）。不能完全解决，尽可能解决的方式就是使用for update把数据锁住，防止幻读现象==
    * 串行化影响并发。

* 快照读（使用视图解决）

  * 什么是快照读？普通的select语句都是采用的快照读。顾名思义：在整个事务的处理过程中，执行相同的一个select语句时，每次都是读取的快照。（快照指的是固定的某个时刻的数据，就像现实世界中的拍照一样，把那个美好的时刻留下来）。也就是说，当事务隔离级别是可重复读，并且执行的select语句是一个普通的select语句时，都会采用快照读的方式读取数据，底层实现原理是：

    - **底层由 MVCC（多版本并发控制）实现**，实现的方式是开始事务后，在执行第一个查询语句后，会创建一个 Read View，后续的查询语句利用这个 Read View，通过这个 Read View 就可以在 undo log（撤销版本链） 版本链找到事务开始时的数据，所以事务过程中每次查询的数据都是一样的，即使中途有其他事务插入了新纪录，是查询不出来这条数据的，所以就很好的避免了幻读问题。

* 当前读（使用锁解决）

  * 当前读，顾名思义：每一次都读取最新的数据。当前读包括：update、delete、insert、select...for update。这个很好理解，因为增删改的时候都要基于最新的数据进行增删改。
  * 而select...for update原理是：对查询范围内的数据进行加锁，不允许其它事务对这个范围内的数据进行增删改。也就是说这个select语句范围内的数据是不允许并发的，只能排队执行，从而避免幻读问题。
  * select...for update加的锁叫做：==next-key lock。==我们可以称其为：**间隙锁 + 记录锁。**间隙锁用来保证在锁定的范围内不允许insert操作。记录锁用来保证在锁定的范围内不允许delete和update操作。