##### 三范式

* 函数依赖：设R(U)是一个属性集U上的关系模式，X 和Y是U的子集。若对于R(U)的任意一个可能的关

  系r，r 中不可能存在两个元组在X上的属性值相等， 而在Y上的属性值不等， 则称“X函数确定

  Y”或“Y函数依赖于X”，记作X→Y。（简单的说，通过学号值能确定唯一一个学生）

  * 分类：

    * 非平凡的函数依赖：X→Y，但Y⊈X则称X→Y是非平凡的函数依赖

      ```txt
      （Sno,Cno）→（Grade）
       x→y,y不在x的范围里
      ```

    * 平凡的函数依赖：X→Y，但Y⊆X 则称X→Y是平凡的函数依赖。

      ```txt
      学号→学号
      ```

    * 对于任一关系模式，平凡函数依赖都是必然成立的，它不反映新的语义。 若不特别声明， 我们总是讨论非平凡函数依赖。

  * 若X→Y，则X称为这个函数依赖的决定因素

  * 若X→Y，Y→X，则记作X←→Y。 v若Y不函数依赖于X，则记作X↛Y

* 完全函数依赖

  * 在R(U)中，如果X→Y，并且对于X的任何一个真子集X’, 都有 X’ ↛ Y, 则称Y对X完全函

    数依赖（**及一个x对映一个y**）

    ![1711106454075](%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E4%B8%89%E8%8C%83%E5%BC%8F.assets/1711106454075.png)



* 部分函数依赖：若X→Y，但Y不完全函数依赖于X，则称Y对X部分函数依赖，记作：

  ![1711106516943](%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E4%B8%89%E8%8C%83%E5%BC%8F.assets/1711106516943.png)

* 传递函数依赖：在R(U)中，如果X→Y(Y⊈X)，Y↛X， Y→Z，Z⊈Y, 则称Z对X传递函数依赖(transitive functional dependency)。

* ![1711106605901](%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E4%B8%89%E8%8C%83%E5%BC%8F.assets/1711106605901.png)
  * 注: 如果Y→X, 即X←→Y，则Z直接依赖于X，而不是传递函数依赖

* 候选码

  * 设K为R<U,F>中的属性或属性组合。若K → U，则K称为R的一个候选码(Candidate 

    Key)。（即可以唯一确定一条记录）

* 主码

  * 若关系模式R有多个候选码，则选定其中的一个做为主码(Primary key)

* 超码

  * 如果U部分函数依赖于K，即K → U,则K称为超码 Surpkey）。候选码是最小的超码，即K的任意一个真子集都不是候选码。（即含有候选码的集合

* 主属性与非主属性

  * 包含在任何一个候选码中的属性 ，称为主属性 （Prime attribute） 
  *  不包含在任何码中的属性称为非主属性（Nonprime attribute）或非码属性（Non-key attribute）

* 全码：整个属性组是码，称为全码（All-key）即全部属性才能确定一条记录。

   



* 第一范式：第一范式：任何一张表都应该有主键，每个字段是原子性的不能再分

  ![image.png](%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E4%B8%89%E8%8C%83%E5%BC%8F.assets/image.png)
  * 这个图问题一：没有主键，问题二：还能拆分

    ![image.png](%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E4%B8%89%E8%8C%83%E5%BC%8F.assets/image-1711099315672.png)

* 第二范式：建立在第一范式基础上的，另外要求所有非主键字段完全依赖主键，不能产生部分依赖。即若关系模式R∈1NF，并且每一个非主属性都完全函数依赖于任何一个候选码，则R∈2NF。

  * 虽然符合第一范式，但是为违反了第二范式

    ![image.png](%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E4%B8%89%E8%8C%83%E5%BC%8F.assets/image-1711168097336.png)

  * 符合第二范式的写法

    ![image.png](%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E4%B8%89%E8%8C%83%E5%BC%8F.assets/image-1711168128420.png)



* 第三范式建立在第二范式基础上：关系模式R<U,F>∈1NF,若R中不存在这样的码X、属性组Y及非主属性Z（Z ⊇ Y）, 使 得X→Y，Y→Z成立，Y ↛ X不成立，则称R<U,F> ∈ 3NF。（即要满足第一范式，且不能满足传递函数依赖。）

  * 这个就违背了第三范式，因为是单一主键，必然符合第二范式，但是班级名称也依赖于班级编号了，产生了传递依赖

    ![image.png](%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E4%B8%89%E8%8C%83%E5%BC%8F.assets/image-1711169053161.png)

    ![image.png](%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E4%B8%89%E8%8C%83%E5%BC%8F.assets/image-1711169100370.png)



* 一对多，两张表多的表加外键。多对多，三张表，关系表加外键。一对一，主键共享

  * 一对一：主键共享。一般真实设计时，用户的账号密码会单独在一张表，其他信息会单独存在另外一张表

    ![image.png](%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E4%B8%89%E8%8C%83%E5%BC%8F.assets/image-1711169440002.png)

  * 外键唯一

    ![image.png](%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E4%B8%89%E8%8C%83%E5%BC%8F.assets/image-1711169962610.png)