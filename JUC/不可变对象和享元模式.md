#### 不可变对象

* 下面的代码在运行时，由于 SimpleDateFormat 不是线程安全的，有很大几率出现 java.lang.NumberFormatException 或者出现不正确的日期解析结果

* 不可变设计

  * 该类类中所有属性都是 final 的 
    - 属性用 final 修饰保证了该属性是只读的，不能修改 
    - 类用 final 修饰保证了该类中的方法不能被覆盖，防止子类无意间破坏不可变性 
  * 保护性拷贝

* 享元模式

  * 当需要重用数量有限的同一类对象时 。flyweight（享元模式）是一种通过与其他类似对象共享尽可能多的数据来最小化内存使用的对象。

  * 体现：在JDK包装类中： Boolean，Byte，Short，Integer，Long，Character 等包装类提供了 valueOf 方法，例如 Long 的valueOf 会缓存 -128~127 之间的 Long 对象，在这个范围之间会重用对象，大于这个范围，才会新建 Long 对象：

    * Byte,Short, Long 缓存的范围都是-128~127
    * Character缓存的范围是0~127
    * Integer的默认范围是-128~127，最小值不能变，但最大值可以通过调整虚拟机参数-Djava.lang.Integer.Integercache.high `来改变
    * Boolean缓存了TRUE和FALSE

  * ==发现 final 变量的赋值也会通过 putfifield 指令来完成，同样在这条指令之后也会加入写屏障，保证在其它线程读到 它的值时不会出现为 0 的情况。==

  * 用final修饰实际上就是为了保护数据的一致性。这里所说的数据一致性，对引用变量来说是引用地址的一致性，对基本类型来说就是值的一致性。 [JDK8之前，匿名内部类访问的局部变量为什么必须要用final修饰_匿名内部类 final-CSDN博客](https://blog.csdn.net/tianjindong0804/article/details/81710268) 

    ![1722410625412](%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1%E5%92%8C%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F.assets/1722410625412.png)

    final修饰符对变量来说，深层次的理解就是保障变量值的一致性。为什么这么说呢？因为引用类型变量其本质是存入的是一个引用地址，说白了还是一个值（可以理解为内存中的地址值）。用final修饰后，这个这个引用变量的地址值不能改变，所以这个引用变量就无法再指向其它对象了。

* 无状态

  * 在 web 阶段学习时，设计 Servlet 时为了保证其线程安全，都会有这样的建议，不要为 Servlet 设置成员变量，这 种没有任何成员变量的类是线程安全的 
  * 因为成员变量保存的数据也可以称为状态信息，因此没有成员变量就称之为【无状态】