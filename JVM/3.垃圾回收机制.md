#### 垃圾回收机制

* 什么是垃圾？
  * 垃圾是指在运行程序中没有任何指针指向的对象，这个对象就是需要被回收的垃圾
  * 如果不及时对内存中的垃圾进行清理，那么，这些垃圾对象所占的内存空间会一直保留到应用程序结束，被保留的空间无法被其他对象使用。甚至可能导致内存溢出。
* 垃圾标记阶段：对象存活判断
  * 在堆里存放着几乎所有的Java对象实例，在GC执行垃圾回收之前，首先需要区分出内存中哪些是存活对象，哪些是已经死亡的对象。只有被标记为已经死亡的对象，GC才会在执行垃圾回收时，释放掉其所占用的内存空间，因此这个过程我们可以称为垃圾标记阶段
  * 那么在JVM中究竟是如何标记一个死亡对象呢?简单来说，当一个对象已经不再被任何的存活对象继续引用时，就可以宣判为已经死亡。
  * ==判断对象存活一般有两种方式:引用计数算法和可达性分析算法==



* 引用计数算法

  * 引用计数算法(Reference Counting)比较简单，对每个对象保存一个整型的引用计数器属性。用于记录对象被引用的情况

  * 对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1；当引用失效时，引用计数器就减1。只要对象A的引用计数器的值为0，即表示对象A不可能再被使用，可进行回收。

  * 优点:实现简单，垃圾对象便于辨识;判定效率高，回收没有延迟性

  * 缺点:

    * 它需要单独的字段存储计数器，这样的做法增加了存储空间的开销

    * 每次赋值都需要更新计数器，伴随着加法和减法操作，这增加了时间开销。

    * **引用计数器有一个严重的问题，即无法处理循环引用的情况。这是一条致命缺陷导致在Java的垃圾回收器中没有使用这类算法**

      <img src="%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6.assets/1705829415671.png" alt="1705829415671" style="zoom:50%;" />

      * 这个就是循环引用

  * **python采用的这个方法**

    * Python如何解决循环引用?
      * 手动解除:很好理解，就是在合适的时机，解除引用关系。
      * 使用弱引用weakref，weakref是Python提供的标准库，旨在解决循环引用。



* 可达性分析(或根搜索算法、追踪性垃圾收集)
  * 相对于引用计数算法而言，可达性分析算法不仅同样具备实现简单和执行高效等特点，更重要的是该算法可以有效地解决在引用计数算法中循环引用的问题，防止内存泄漏的发生。
  
  * 相较于引用计数算法，这里的可达性分析就是Java、C#选择的。这种类型的垃圾收集通常也叫作追踪性垃圾收集 (Tracing GarbageCollection)
  
  * 思路：所谓"GC Roots"根集合就是一组必须活跃的引用。
  
    * 可达性分析算法是以根对象集合(GCRoots)为起始点，按照从上至下的方式搜索被根对象集合所连接的目标对象是否可达。
  
    * 使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为引用链(Reference Chain)
  
    * 如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象已经死亡，可以标记为垃圾对象。
  
    * 在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象。
  
      ![1705917183565](%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6.assets/1705917183565.png)
  
  * 哪些可以成为GCRoots
  
    * 虚拟机栈中引用的对象
    * 比如:各个线程被调用的方法中使用到的参数、局部变量等。
    * 本地方法栈内JNI(通常说的本地方法)引用的对象
    * 方法区中类静态属性引用的对象
      * 比如:Java类的引用类型静态变量
    * 方法区中常量引用的对象
      * 比如:字符串常量池(stringTable)里的引用
    * 所有被同步锁synchronized持有的对象Java虚拟机内部的引用。
    * 基本数据类型对应的Class对象，一些常驻的异常对象(如:Nu1lPointerException、0utOfMemoryError)，系统类加载器
    * 反映java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。
  
  * 除了这些固定的GC Roots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完整GC Roots集合。比如:分代收集和局部回收(PartialG)
  
  * 如果只针对Java堆中的某一块区域进行垃圾回收(比如:典型的只针对新生代)，必须考虑到内存区域是虚拟机自己的实现细节，更不是孤立封闭的，这个区域的对象完全有可能被其他区域的对象所引用，这时候就需要一并将关联的区域对象也加入GC Roots集合中去考虑，才能保证可达性分析的准确性。
  
  * 如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能保障一致性的快照中进行。这点不满足的话分析结果的准确性就无法保证。
  
    * 这点也是导致GC进行时必须“stop The world"的一个重要原因，即使是号称(几乎)不会发生停顿的CMS收集器中，枚举根节点时也是必须要停顿的。
  
* 判定一个对象obj A是否可回收，至少要经历两次标记过程:
  
  * 1.如果对象obj A到 GC Roots没有引用链，则进行第一次标记。
  
  * 2.进行筛选，判断此对象是否有必要执行finalize()方法
    
    * 如果对象obj A没有重写finalize()方法，或者finalize()方法已经被虚拟机调用过，则虚拟机视为“没有必要执行”，obj A 被判定为不可触及的。
    
    * 如果对象obj A重写了finalize()方法，且还未执行过，那么obj A会被插入到F-Queue队列中，由一个虚拟机自动创建的、低优先级的 Finalizer 线程触发其finalize()方法执行。
    
    * ==finalize()方法是对象逃脱死亡的最后机会，稍后GC会对F-Queue队列中的对象进行第二次标记。如果obj A在finalize()方法中与引用链上的任何一个对象建立了联系，那么在第二次标记时，obj A会被移出“即将回收”集合。之后，对象会再次出现没有引用存在的情况。在这个情况下，finalize方法不会被再次调用，对象会直接变成不可触及的状态，也就是说，一个对象的finalize方法只会被调用一次。==
    
      ```java
      public class CanReliveObj {
          public static CanReliveObj obj;//类变量，属于 GC Root
          //此方法只能被调用一次
          @Override
          protected void finalize() throws Throwable {
              super.finalize();
              System.out.println("调用当前类重写的finalize()方法");
              obj = this;//当前待回收的对象在finalize()方法中与引用链上的一个对象obj建立了联系
          }
          public static void main(String[] args) {
              try {
                  obj = new CanReliveObj();
                  // 对象第一次成功拯救自己
                  obj = null;
                  System.gc();//调用垃圾回收器
                  System.out.println("第1次 gc");
                  // 因为Finalizer线程优先级很低，暂停2秒，以等待它
                  Thread.sleep(2000);
                  if (obj == null) {
                      System.out.println("obj is dead");
                  } else {
                      System.out.println("obj is still alive");
                  }
                  System.out.println("第2次 gc");
                  // 下面这段代码与上面的完全相同，但是这次自救却失败了
                  obj = null;
                  System.gc();
                  // 因为Finalizer线程优先级很低，暂停2秒，以等待它
                  Thread.sleep(2000);
                  if (obj == null) {
                      System.out.println("obj is dead");
                  } else {
                      System.out.println("obj is still alive");
                  }
              } catch (InterruptedException e) {
                  e.printStackTrace();
              }
          }
      }
      调用当前类重写的finalize()方法
      第1次 gc
      obj is still alive
      第2次 gc
      obj is dead
      ```
    
      







##### 对象的finalization机制

* Java语言提供了对象终止(finalization)机制来允许开发人员提供对象被销毁之前的自定义处理逻辑。
* 当垃圾回收器发现没有引用指向一个对象，即:垃圾回收此对象之前，总会先调用这个对象的finalize()方法。
* finalize()方法允许在子类中被重写，用于在对象被回收时进行资源释放通常在这个方法中进行一些资源释放和清理的工作，比如关闭文件、套接字和数据库连接等
* 永远不要主动调用某个对象的finalize()方法，应该交给垃圾回收机制调用。理由包括下面三点:
  * 在finalizd()时可能会导致对象复活。
  * finalize()方法的执行时间是没有保障的，它完全由GC线程决定，极端情况下若不发生GC，则finalize()方法将没有执行机会。
  * 一个糟糕的finalize()会严重影响GC的性能。
* 从功能上来说，finalize()方法与C++中的析构函数比较相似，但是Java采用的是基于垃圾回收器的自动内存管理机制，所以finalize()方法在本质上不同于C++中的析构函数。
* 由于finalize()方法的存在，虚拟机中的对象一般处于三种可能的状态
  * 如果从所有的根节点都无法访问到某个对象，说明对象已经不再使用了。一般来说，此对象需要被回收。但事实上，也并非是“非死不可”的，这时候它们暂时处于“缓北刑”阶段。一个无法触及的对象有可能在某一个条件下“复活”自己，如果这样，么对它的回收就是不合理的，为此，定义虚拟机中的对象可能的三种状态。如下:
  * ==可触及的:从根节点开始，可以到达这个对象。==
  * ==可复活的:对象的所有引用都被释放，但是对象有可能在finalize()中复活。==
  * ==不可触及的:对象的finalize()被调用,I并且没有复活，那么就会进入不可触及状态。不可触及的对象不可能被复活，因为finalize()只会被调用一次。==
  * 以上3种状态中，是由于finalize()方法的存在，进行的区分。只有在对象不可触及时才可以被回收。



