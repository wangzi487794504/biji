#### 代码优化

* 使用逃逸分析，编译器可以对代码做如下优化:
  * 栈上分配。将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配。
  * 同步省略。如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步。
  * 分离对象或标量替换。有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分(或全部) 可以不存储在内存，而是存储在CPU寄存器中。

##### 栈上分配

* ==JIT编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无须进行垃圾回收了==
* 常见的栈上分配的场景
  * 在分别是给成员变量赋值、方法返回值实例引用传递



#### 同步省略

* 线程同步的代价是相当高的，同步的后果是降低并发性和性能

* 在动态编译同步块的时候，**JIT编译器可以借助逃逸分析来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程。****

* 如果没有，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫同步省略，也叫锁消除。

  ![1704939741135](%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%E7%9A%84%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96.assets/1704939741135.png)

  * 代码中对hollis这个对象进行加锁，但是hollis对象的生命周期只在f()方法中，并不会被其他线程所访问到，所以在JIT编译阶段就会被优化掉。
  * 优化成:（不过上面这个代码本身就没有意义，因为这个锁没有用）
  * 字节码的时候没有优化，只有运行时才优化

![1704939780715](%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%E7%9A%84%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96.assets/1704939780715.png)

 



##### 标量替换

* 标量(scalar) 是指个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量

  * 基本类型就是标量

* 相对的，那些还可以分解的数据叫做聚合量 (Aggregate)，Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量。

* **在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换。**

  ![1704940380469](%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%E7%9A%84%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96.assets/1704940380469.png)
  * point就是一个聚合量，他可以分解为x和y两个标量

  * 经过标量替换，就变成

    ![1704941092771](%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%E7%9A%84%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96.assets/1704941092771.png)





#### 总结

* 堆是分配对象的唯一选择

  * 虽然有因为逃逸分析造成的栈上分配，但是目前还没有应用，目前在hotspot只应用了标量替换

* 相关参数

  * 参数-server:启动Server模式，因为在Server模式下，才可以启用逃逸分析

    ![1704941425728](%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%E7%9A%84%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96.assets/1704941425728.png)

    * 64位默认就是服务器

  * 参数 -XX:+DoEscapeAnalysis: 启用逃逸分析

* 逃逸分析并不成熟

  * 其根本原因就是无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。