#### 类的主动使用和被动使用

* 主动使用
  * 创建类的实例
  * 访问某个类或接口的静态变量，或者对该静态变量赋值
  * 调用类的静态方法
  * 反射（比如:Class.forName ( "com.atguigu. Test") )
  * 初始化一个类的子类
  * Java虚拟机启动时被标明为启动类的类
  * JDK 7开始提供的动态语言支持:
    * java . lang. invoke.MethodHandle实例的解析结果
    * REF_getstatic、REF_putstatic、REF_invokestatic句柄对应的类没有初始化，则初始化
* 除了以上七种情况，其他使用Java类的方式都被看作是对类的被动使用都不会导致类的初始化。
  * 相当于只有加载和链接





#### 数据区内部结构

* JVM内存布局规定了Java在运行过程中内存申请、分配、管理的策略，保证了JA的高效稳定运行。不同的JVM对于内存的划分方式和管理机制存在着部分差异。（基本是方法区不同）

  ![1703339586354](%E7%B1%BB%E7%9A%84%E4%B8%BB%E5%8A%A8%E4%BD%BF%E7%94%A8%E4%B8%8E%E8%A2%AB%E5%8A%A8%E4%BD%BF%E7%94%A8.assets/1703339586354.png)

* Java虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程对应的数据区域会随着线程开始和结束而创建和销毁。

  ![1703339681797](%E7%B1%BB%E7%9A%84%E4%B8%BB%E5%8A%A8%E4%BD%BF%E7%94%A8%E4%B8%8E%E8%A2%AB%E5%8A%A8%E4%BD%BF%E7%94%A8.assets/1703339681797.png)
  * 灰色的为单独线程私有的,红色的为多个线程共享的。
    * 每个线程:独立包括程序计数器、栈、本地栈。
    * 线程间共享:堆、堆外内存（永久代或元空间、代码缓存)
  * 优化基本都是共享的

* 线程

  * 线程是一个程序里的运行单元。JVM允许一个应用有多个线程并行的执行。
  * 在Hotspot JVM里，每个线程都与操作系统的本地线程直接映射。当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后，本地线程也会回收。
  * 操作系统负责所有线程的安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，它就会调用Java线程中的run ()方法。





#### PC寄存器

* JVM中的**程序计数寄存器**（Program counter Register）中，Register 的命名源于CPU的寄存器，寄存器存储指令相关的现场信息，CPU只有把数据装载到寄存器才能够运行。

* 这里，并非是广义上所指的物理寄存器，或许将其翻译为PC计数器（或指令计数器）会更加贴切(也称为程序钩子)，并且也不容易引起一些不必要的误会。**JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟。**

* 作用

  * ==PC寄存器用来存储指向下一条指令的地址,也即将要执行的指令代码。由执行引擎读取下一条指令。==

    <img src="%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84.assets/1703388522383.png" alt="1703388522383" style="zoom:50%;" />

  * 它是一块很小的内存空间，几乎可以忽略不记。也是运行速度最快的存储区域。

  * 在JVM规范中，**每个线程都有它自己的程序计数器，是线程私有的**，生命周期与线程的生命周期保持一致。

  * 任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程

    正在执行的Java方法的JVM指令地址。

  * **如果是在执行native方法，则是未指定值（undefined)。**

* 它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。

* ==字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。==

* **它是唯一一个在Java虚拟机规范中没有规定任何OutMemoryError情况的区域。**

* 

  ```class
  public class test {
      public static void main(String[] args) {
          int a=5;
          int b=6;
          int c=a+b;
          String s="abc";
          System.out.println(a);
          System.out.println(b);
      }
  }
  ```

  

  * iconst_5取数字5保存到索引为1的位置，bipush取6放在索引为2的地方，把索引1和索引导入进来，相加。进行一个加操作，保存到索引为3的位置上。ldc就代表从常量池里取东西，从#2取，#2是String，他从#27里面取abc。 getstatic去调用静态打印方法#3，#3对应着#28和#29，28指向34,34指向system，29指向35,36。指向out和print

  * 0 1 2 4 5就是偏移地址(指令地址)，就是PC寄存器存储的东西，右边一列这些都是操作指令。

    ![1703408956195](%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84.assets/1703408956195.png)

* 常见面试题目
  * 使用PC寄存器存储字节码指令地址有什么用呢?为什么使用PC寄存器记录当前线程的执行地址呢?
    * 因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。
    * JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。
  * PC寄存器为什么会被设定为线程私有?(保存现场)
    * 我们都知道所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法，CPU会不停地做任务切换，这样必然导致经常中断或恢复，如何保证分毫无差呢?为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器，这样一来各个线程之间便可以进行独立计算，从而不会出现相互千扰的情况。
    * 由于CPU时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。
    * 这样必然导致经常中断或恢复，如何保证分毫无差呢?每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。



#### 虚拟机栈

* **栈是运行时的单位,而堆是存储的单位。**

* ==即:栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题,即数据怎么放、放在哪儿。==

* **一个线程对应一个java虚拟机栈。每个线程在创建时都会创建一个虚拟机栈（线程私有的）**，==其内部保存一个个的栈帧(stack Frame)，对应着一次次的Java方法调用。==

* 作用：主管Java程序的运行，它保存方法的局部变量、部分结果，并参与方法的调用和返回。

* **生命周期：与线程一致**

* 栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器。

* JVM直接对Java栈的操作只有两个:

  * 每个方法执行，伴随着进栈(入栈、压栈)>执行结束后的出栈工作
  * **对于栈来说不存在垃圾回收问题**

* 虚拟机栈常见的异常

  * java虚拟机规范允许java栈的大小是动态的或者是固定不变的

    * 如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个stackoverflowError异常。（比如方法递归嵌套，出不去），可以通过-Xss参数设置栈空间大小

      ![1703469726279](%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84.assets/1703469726279.png)

    * 如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈,那Java虚拟机将会抛出一个OutOfMemoryError异常。

* java命令网站：https://docs.oracle.com/en/java/javase/11/tools/java.html#GUID-3B1CE181-CD30-4178-9602-230B800D4FAE

* 栈中的存储

  * 每个线程都有自己的栈，栈中的数据都是以栈帧（Stack Frame的格式存在）。
  * 在这个线程上正在执行的每个方法都各自对应一个栈帧(stack Frame)。（方法和栈帧是一对一关系）
  * 栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。

* 栈运行原理
  * JVM直接对Java栈的操作只有两个，就是对栈帧的压栈和出栈，遵循“先进后出”/“后进先出”原则。
  * 在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的，这个栈帧被称为当前栈帧(Current Frame)，与当前栈帧相对应的方法就是当前方法(CurrentMethod)，定义这个方法的类就是当前类(current class)。
  * 执行引擎运行的所有字节码指令只针对当前栈帧进行操作。
  * 如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前帧。

* 不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧之中引用另外一个线程的栈帧。

* 如果当前方法调用了其他方法，方法返回之际，**当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。**

* Java方法有两种返回函数的方式，一种是正常的函数返回，使用return指令;另外一种是抛出异常。不管使用哪种方式，都会导致栈帧被弹出。

* void方法写不写return，最终的结果都会有return。

  ```java
  public class test {
      public static void main(String[] args) {
          int a=5;
          test s=new test();
          s.methodA();
          s.methodB();
      }
      public void methodA(){
          int i=10;
          int j=20;
      }
      public int methodB(){
          int k=30;
          int m=40;
          return k;
      }
  }
  ```

  ```class
    public void methodA();
      descriptor: ()V
      flags: ACC_PUBLIC
      Code:
        stack=1, locals=3, args_size=1
           0: bipush        10
           2: istore_1
           3: bipush        20
           5: istore_2
           6: return
        LineNumberTable:
          line 20: 0
          line 21: 3
          line 22: 6
        LocalVariableTable:
          Start  Length  Slot  Name   Signature
              0       7     0  this   LUSE/test;
              3       4     1     i   I
              6       1     2     j   I
  
    public int methodB();
      descriptor: ()I
      flags: ACC_PUBLIC
      Code:
        stack=1, locals=3, args_size=1
           0: bipush        30
           2: istore_1
           3: bipush        40
           5: istore_2
           6: iload_1
           7: ireturn
        LineNumberTable:
          line 24: 0
          line 25: 3
          line 26: 6
        LocalVariableTable:
          Start  Length  Slot  Name   Signature
              0       8     0  this   LUSE/test;
              3       5     1     k   I
              6       2     2     m   I
  
  ```

  * 返回的一个是ireturn，一个是return





* 栈帧的内部结构

  * 每个栈帧中存储着:

    * 局部变量表（Local variables)

    * 操作数栈（operand stack）(或表达式栈)

    * 动态链接(Dynamic Linking)（或指向运行时常量池的方法引用)

    * 方法返回地址（Return Address)（或方法正常退出或者异常退出的定义)

    * 一些附加信息

      ![1703472135301](%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84.assets/1703472135301.png)

  ####栈帧之局部变量表详解（又称为局部变量数组或者本地变量表）：

  * 定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量，这些数据类型包括各类基本数据类型、对象引用(reference)，以及returnAddress（返回值）类型。

  * 由于局部变量表是建立在线程的栈上，是线程的私有数据，因此不存在数据安全问题
    **局部变量表所需的容量大小是在编译期确定下来的（即生成class文件时确定的）**，并保存在方法的Code属性的maximum local variables数据项中。**在方法运行期间是不会改变局部变量表的大小的。这个大小指的是slot的数量，而单个slot的具体大小是由具体的虚拟机决定**

    ![1703474086047](%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84.assets/1703474086047.png)

  * 参数值的存放总是在局部变量数组的index0开始，到数组长度-1的索引结束。

  * **局部变量表，最基本的存储单元是slot（变量槽)**

  * 局部变量表中存放编译期可知的各种基本数据类型(8种)，引用类型( reference) ，returnAddress类型。

  * 在局部变量表里，32位以内的类型只占用一个slot(包括returnAddress类型），**64位的类型(long和double)占用两个slot。（除了这两个，其他都是32）**

    * byte 、 short 、 char在存储前被转换为int，boolean也被转换为int，0表示false ，非o表示true。
    * long和double 则占据两个slot。

    ```class
     public int methodB();
        descriptor: ()I
        flags: ACC_PUBLIC
        Code:
          stack=1, locals=3, args_size=1
             0: bipush        30
             2: istore_1
             3: bipush        40
             5: istore_2
             6: iload_1
             7: ireturn
          LineNumberTable:
            line 24: 0
            line 25: 3
            line 26: 6
          LocalVariableTable:
            Start  Length  Slot  Name   Signature
                0       8     0  this   LUSE/test;
                3       5     1     k   I
                6       2     2     m   I
    
    ```

    * 像这个methodB方法局部变量表就是三个Slot，分辨是变量this,k,m， Signature表示的是类型的意思

* **方法嵌套调用的次数由栈的大小决定。**一般来说，栈越大，方法嵌套调用次数越多。对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，**它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。****

* **局部变量表中的变量只在当前方法调用中有效。**在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。**当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。**



* 逐步介绍，名字是main方法，L代表是一个对象，访问标识说明是一个公开的静态的

  ![1703475216994](%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84.assets/1703475216994.png)

* 字节码和上面一样，异常表就是说明该方法有没有异常，杂项指明了局部变量表最大空间和字节码指令的长度

  ![1703475316171](%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84.assets/1703475316171.png)

* java字节码指令的行号和代码的行号(最右边一列)对应关系

  ![1703475394061](%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84.assets/1703475394061.png)

* 局部变量表，关于局部变量的描述，有三个局部变量，分别对应着String[] args，int a，test s，名字就是变量的名字，描述符就是什么类型，PC仍然是字节码指令的行号。起始PC和长度在一个是描述当前变量作用域的范围，前者是声明，后者是范围长度，范围是这两个相加

  ![1703475583741](%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84.assets/1703475583741.png)





* 关于slot

  * JVM会为局部变量表中的每一个slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值

  * 当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会按照顺序被复制到局部变量态中的每一个slot上

  * 如果需要访问局部变量表中一个64bit的局部变量值时,只需要使用前一个索引即可。(比如:访问long或double类型变量)

  * **如果当前帧是由构造方法或者实例方法创建的,那么该对象引用this将会存放在index为0的slot处**，其余的参数按照参数表顺序继续排列。

  * **栈帧中的局部变量表中的槽位是可以重用的，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变量就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的。**

    ![1703480842442](%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84.assets/1703480842442.png)

    * 长度为3，所以存在重复利用

* 静态变量与局部变量的对比

  ![1703481055717](%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84.assets/1703481055717.png)
  * 成员变量有默认初始化赋值。类变量在prepare阶段会分配默认值，初始化阶段分配具体的值。实例变量随着对象的创建，在实例空间分配实例变量空间并进行默认赋值。局部变量必须显示赋值。
  * 在栈帧中，与性能调优关系最为密切的部分就是前面提到的局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递。
  * **局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。**



#### 栈帧之操作数栈

* 每一个独立的栈帧中除了包含局部变量表以外，还包含一个后进先出(Last-In-First-out）的操作数栈，也可以称之为表达式栈(Expression stack) 。

* 操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据,即入栈(push)/出栈(pop)。
  >某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出
  >栈。使用它们后再把结果压入栈。
  >比如:执行复制、交换、求和等操作

* ![1703482229090](%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84.assets/1703482229090.png)
  
* istore就是入操作数栈，iload就是出操作数栈
  
* 操作数栈，主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。

* 操作数栈就是JVM执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这个方法的操作数浅是空的。（空数组）

* 每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的Code属性中，为max_stack的值。

* 栈中的任何一个元素都是可以任意的Java数据类型。

  * 32bit的类型占用一个栈单位深度
  * 64bit的类型占用两个栈单位深度

* 操作数栈并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈（push）和出栈（pop）操作来完成一次数据访问。

* 如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新Pc寄存器中下一条需要执行的字节码指令。

* 操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译器期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证。

* 另外，我们说Java虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈。

  ![1703484586906](%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84.assets/1703484586906.png)
  * `iconst` 系列指令用于表示将常量整数值压入操作数栈，但是只能表示特定的几个整数值，这些整数通常在 -1 到 5 之间。例如，`iconst_0` 表示将整数值 0 压入操作数栈，`iconst_1` 表示将整数值 1 压入操作数栈，以此类推。这些指令都是单字节的，因为它们只需要指定指令本身即可，没有额外的操作数。

    `bipush` 指令用于将一个字节范围内的整数值 (-128 到 127) 压入操作数栈。因为字节码是字节组成的，使用 `bipush` 指令可以更高效地表示 -128 到 127 范围内的整数，只需要使用一个额外的字节表示常量值即可。

    ![1703487002043](%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84.assets/1703487002043.png)

    ![1703487121503](%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84.assets/1703487121503.png)

  * 一个Int类型的，进操作栈由于数值在byte范围内，就赋予byte的内存空间，出栈再为Int类型。357那个int被变为short类型。最大深度为2是因为iconst不在这，剩下两个在栈内，相加时两个都出栈了，把相加的结果再进栈

#### 栈顶缓存技术

* 基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将**需要更多的指令分派（instruction dispatch）次数和内存读/写次数。**
* 由于操作数是存储在内存中的，因此频繁地执行内存读/写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者们提出了栈顶缓存（Tos，Top-of-stack Cashing）技术，将栈顶元素全部缓存在物理cPu的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率。