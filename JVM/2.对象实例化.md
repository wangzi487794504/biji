#### 对象创建的几种方式

* new
* Class的newInstance()：反射的方式，只能调用空参的构适器，权限必须是public
* Constructor的newInstance(Xxx)：反射的方式，可以调用空参、带参的构造器，权限没有要求
* 使用clone()：不调用任何构造器，当前类需要实现Cloneable接口，实现clone0
* 使用反序列化：从文件中、从网络中获取一个对象的二进制流
* 第三方库Objenesis



##### 创建对象的步骤

* 1.判断对象对应的类是否加载、链接、初始化
* 2.为对象分配内存（首先计算对象占用空间大小，接着在堆中划分一块内存外新对象。
  如果实例成员变量是引用变量，仅分配引用变量空间即可，即4个字节大小）
  * 如果内存规整 ：指针碰撞 
  * 如果内存不规整：虚拟机需要维护一个列表，空闲列表分配 （）
  
* 3.处理并发安全问题
  * 采用CAS配上失败重试保证更新的原子性
  * 每个线程预先分配一块TLAB
* 4.初始化分配到的空间所有属性设置默认值，保证对象实例字段在不赋值时可以直接使用
* 5.设置对象的对象头
* 6.执行init方法进行初始化



##### 对象实例化过程

* 加载类元信息 
* 为对象分配内存 
* 处理并发问题  
* 属性的默认初始化(零值初始化)
* 设置对象头的信息  
* 属性的显式初始化、代码块中初始化、构造器中初始化





##### 对象内存布局

* 他包括对象头，实例数据，对齐填充三部分

* 对象头

  * 运行时元数据
    * 哈希值( HashCode)、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳
  * 类型指针：指向类元数据InstanceKlass，确定该对象所属的类型
  * 如果是数组，还要记录数组的长度

* 实例数据

  * 它是对象真正存储的有效信息，包括程序代码中定义的各种类型的字段(包括从父类继承下来的和本身拥有的字段）
  * 规则：
    * 相同宽度的字段总是被分配在一起
    * **父类中定义的变量会出现在子类之前**
    * 如果CompactFields参数为true(默认为true)：子类的窄变量可能插入到父类变量的空隙

* 对齐填充：不是必须的，也没特别含义，仅仅起到占位符的作用

  ![1705319455856](%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96.assets/1705319455856.png)





##### 对象的访问定位

* 方式一：句柄访问

  ![1705321736390](%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96.assets/1705321736390.png)
  * 缺点：多指向一次
  * 优点：当发生移动时，只需要修改句柄就行，引用不用修改

* 方式二：直接指针（HotSpot用的这个）

  ![1705321789465](%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96.assets/1705321789465.png)





##### 直接内存概述

* 不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。

* 直接内存是在Java堆外的、直接向系统申请的内存区间。

* 来源于NIO，通过存在堆中的DirectByteBuffer操作Native内存通常，访问直接内存的速度会优于Java堆。即读写性能高。

  * 因此出于性能考虑，读写频繁的场合可能会考虑使用直接内存。

  * Java的NIO库允许Java程序使用直接内存，用于数据缓冲区

    ```JAVA
        public static void main(String[] args){
            //直接分配本地内存空间
            ByteBuffer byteBuffer = ByteBuffer.allocateDirect(BUFFER);
            System.out.println("直接内存分配完毕，请求指示！");
    
            Scanner scanner = new Scanner(System.in);
            scanner.next();
    
            System.out.println("直接内存开始释放！");
            byteBuffer = null;
            System.gc();
            scanner.next();
        }
    ```

    

<img src="%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96.assets/1705556863093.png" alt="1705556863093" style="zoom:50%;" />

* 它也有OOM异常

* 缺点

  >分配回收成本较高不受JVM内存回收管理

* 直接内存大小可以通过MaxDirectMemorysize设置
* 如果不指定，默认与堆的最大值-Xmx参数值一致