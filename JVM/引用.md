#### 引用

* 我们希望能描述这样一类对象:当内存空间还足够时，则能保留在内存中;如果内存空间在进行垃圾收集后还是很紧张，则可以抛弃这些对象。

* 在JDK 1.2版之后，Java对引用的概念进行了扩充，将引用分为强引用(strongReference)、软引用(Soft Reference)、弱引用(Weak Reference)和虚引用(Phantom Reference)4种，这4种引用强度依次逐渐减弱。

* 强引用(strongReference):最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“object obj=new object()”这种引用关系。**无论任何情况下只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象**

  >* 在Java程序中，最常见的引用类型是强引用(普通系统99%以上都是强引用)，也就是我们最常见的普通对象引用，也是默认的引用类型。
  >* 当在Java语言中使用new操作符创建一个新的对象，并将其赋值给一个变量的时候，这个变量就成为指向该对象的一个强引用。
  >* 强引用的对象是可触及的，垃圾收集器就永远不会回收掉被引用的对象
  >* 对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应(强)引用赋值为nu11，就是可以当做垃圾被收集了，当然具体回收时机还是要看垃圾收集策略。
  >* 相对的，软引用、弱引用和虚引用的对象是软可触及、弱可触及和虚可触及的，在一定条件下，都是可以被回收的。所以，强引用是造成Java内存泄漏的主要原因之一。

* 软引用(softReference)在系统将要发生内存溢出之前，将会把这些对象列入回收范围之中进行第二次回收。**如果这次回收后还没有足够的内存，才会抛出内存溢出异常**

  >* 软引用是用来描述一些还有用，但非必需的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。
  >* 软引用通常用来实现内存敏感的缓存。比如:高速缓存就有用到软引用。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。
  >* 垃圾回收器在某个时刻决定回收软可达的对象的时候，会清理软引用，并可选地把引用存放到一个引用队列(Reference Queue)
  >* 类似弱引用，只不过Java虚拟机会尽量让软引用的存活时间长一些，迫不得已才清理，空间不够或者要OOM就会清除弱引用。

  ```java
  0bject obj= new Object();//声明强引用
  SoftReference<Object>sf = new SoftReference<Object>(obj);//弱引用
  obj = null;//销毁强引用
  ```

  

* 弱引用(WeakReference):**被弱引用关联的对象只能生存到下一次垃圾收集之前。当垃圾收集器工作时，无论内存空间是否足够，都会回收掉被弱引用关联的对象。**

  > * java的java.lang.ref提供好了 WeakReference，它是一个弱引用类，用这个类实现的都是弱引用类型
  > * 弱引用对象与软引用对象的最大不同就在于，当GC在进行回收时，需要通过算法检查是否回收软引用对象，而对于弱引用对象，GC总是进行回收。弱引用对象更容易、更快被GC回收。
  > * 弱引用也是用来描述那些非必需对象，只被弱引用关联的对象只能生存到下一次垃圾收集发生为止。在系统GC时，只要发现弱引用，不管系统堆空间使用是否充足，都会回收掉只被弱引用关联的对象。
  > * 但是，由于垃圾回收器的线程通常优先级很低，因此，并不一定能很快地发现持有弱引用的对象。在这种情况下，弱引用对象可以存在较长的时间。
  > * 弱引用和软引用一样，在构造弱引用时，也可以指定一个引用队列，当弱引用对象被回收时，就会加入指定的引用队列，通过这个队列可以跟踪对象的回收情况。
  > * 软引用、弱引用都非常适合来保存那些可有可无的缓存数据。如果这么做，当系统内存不足时，这些缓存数据会被回收，不会导致内存溢出。而当内存资源充足时，这些缓存数据又可以存在相当长的时间，从而起到加速系统的作用。
  > * 案例：WeakHashMap，public class WeakHashMap<K,V>    extends AbstractMap<K,V>    implements Map<K,V> 。但是它的Entry继承了private static class Entry<K,V> extends WeakReference<Object> implements Map.Entry<K,V>

  ```java
          //构造了弱引用
          WeakReference<User> userWeakRef = new WeakReference<User>(new User(1, "songhk"));
          //从弱引用中重新获取对象
          System.out.println(userWeakRef.get());
  ```

  

* 虚引用(PhantomReference):一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获得一个对象的实例。**为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。**

  > * 也称为“幽灵引用”或者“幻影引用”，是所有引用类型中最弱的一个。
  > * 一个对象是否有虚引用的存在，完全不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它和没有引用几乎是一样的，随时都可能被垃圾回收器回收。
  > * 它不能单独使用，也无法通过虚引用来获取被引用的对象。当试图通过虚引用的get()方法取得对象时，总是nu11。
  > * 为一个对象设置虚引用关联的唯一目的在于跟踪垃圾回收过程。比如:能在这个对象被收集器回收时收到一个系统通知。
  > * jdk1.2给了public class PhantomReference<T> extends Reference<T> 实现虚引用

* 终结器引用

  > * 它用以实现对象的finalize()方法，也可以称为终结器引用。
  > * 无需手动编码，其内部配合引用队列使用。
  > * 在GC时，终结器引用入队。由Finalizer线程通过终结器引用找到被引用对象并调用它的finalize()方法，第二次GC时才能回收被引用对象。