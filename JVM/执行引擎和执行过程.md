#### 执行引擎

* 执行引擎是]ava虚拟机核心的组成部分之一。
* “虚拟机”是一个相对于“物理机”的概念，这两种机器都有代码执行能力，其区别是物理机的执行引擎是直接建立在处理器、缓存、指令集和操作系统层面上的，而虚拟机的执行引擎则是由软件自行实现的，因此可以不受物理条件制约地定制指令集与执行引擎的结构体系，能够执行那些不被硬件直接支持的指令集格式。
* JVM的主要任务是负责装载字节码到其内部，但字节码并不能够直接运行在操作系统之上，因为字节码指令并非等价于本地机器指令，它内部包含的仅仅只是一些能够被JVM所识别的字节码指令、符号表，以及其他辅助信息。
* 那么，如果想要让一个Java程序运行起来，执行引擎(Execution Engine)的任务就是将字节码指令解释/编译为对应平台上的本地机器指令才可以。简单来说，JVM中的执行引擎充当了将高级语言翻译为机器语言的译者。

* 问题:什么是解释器( Interpreter），什么是JIT编译器?
  * 解释器:当Java虚拟机启动时会根据预定义的规范对字节码采用逐行解释的方式执行，将每条字节码文件中的内容“翻译”为对应平台的本地机器指令执行。
  * JIT (Just In Time Compiler)编译器:就是虚拟机将源代码直接编译成和本地机器平台相关的机器语言。

* java编译和执行过程，两种执行路径

  ![1705560266963](%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E.assets/1705560266963.png)



##### 指令

* 机器指令：各种用二进制编码方式表示的指令，叫做机器指令码。人们用它采编写程序，这就是机器语言。

* 指令：由于机器码是有0和1组成的二进制序列，可读性实在太差，于是人们发明了指令。指令就是把机器码中特定的o和1序列，简化成对应的指令（一般为英文简写，如mov，inc等），可读性稍好

  * 由于不同的硬件平台，执行同一个操作，对应的机器码可能不同，所以不同的硬件平台的同一种指令(比如mov)，对应的机器码也可能不同。

* 指令集：

  * 不同的硬件平台，各自支持的指令，是有差别的。因此每个平台所支持的指令，称之为对应平台的指令集。
  * 如常见的x86指令集，对应的是x86架构的平台。ARM指令集，对应的是ARM架构的平台

* 汇编语言

  * 在汇编语言中，用助记符(Mnemonics）代替机器指令的操作码，用地址符号(Symbo1）或标号(Labe1)代替指令或操作数的地址。
  * 在不同的硬件平台，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令。
    由于计算机只认识指令码，所以用汇编语言编写的程序还必须翻译成机器指令码，计算机才能识别和执行。

* 高级语言

  * 当计算机执行高级语言编写的程序时，仍然需要把程序解释和编译成机器的指令码。完成这个过程的程序就叫做解释程序或编译程序。

    <img src="%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E.assets/1705561325924.png" alt="1705561325924" style="zoom:50%;" />

* 字节码
  * 字节码是一种中间状态（中间码）的二进制代码（文件），它比机器码更抽象，需要直译器转译后才能成为机器码
  * 字节码的实现方式是通过编译器和虚拟机器。编译器将源码编译成字节码，特定平台上的虚拟机器将字节码转译为可以直接执行的指令。
  * 在Java的发展历史里，一共有两套解释执行器，即古老的字节码解释器、现在普遍使用的模板解释器。
  * 字节码解释器在执行时通过纯软件代码模拟字节码的执行，效率非常低下。而模板解释器将每一条字节码和一个模板函数相关联，模板函数中直接产生这条字节码执行时的机器码，从而很大程度上提高了解释器的性能。
  * 在HotSpot VM中，解释器主要由Interpreter模块和code模块构成。
    * Interpreter模块:实现了解释器的核心功能
    *  Code模块:用于管理Hotspot VM在运行时生成的本地机器指令
  * 由于解释器在设计和实现上非常简单，因此除了Java语言之外，还有许多高级语言同样也是基于解释器执行的，比如Python、Perl、Ruby等。但是在今天，基于解释器执行已经沦落为低效的代名词，并且时常被一些C/C++程序员所调侃。
  * 为了解决这个问题，**JVM平台支持一种叫作即时编译的技术。即时编译的目的是避免函数被解释执行，而是将整个函数体编译成为机器码，每次函数执行时，只执行编译后的机器码即可，这种方式可以使执行效率大幅度提升。**
  * HotSpot VM是目前市面上高性能虚拟机的代表作之一。它采用解释器与即时编译器并存的架构。在Java虚拟机运行时，解释器和即时编译器能够相互协作，各自取长补短，尽力去选择最合适的方式来权衡编译本地代码的时间和直接解释执行代码的时间。
* HotSpot运行方式
  * ==当虚拟机启动的时候，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成再执行，这样可以省去许多不必要的编译时间。并且随着程序运行时间的推移，即时编译器逐渐发挥作用，根据热点探测功能，将有价值的字节码编译为本地机器指令，以换取更高的程序执行效率。==
  * **问题：有些开发人员会感觉到诧异，既然HotSpot VM中已经内置JIT编译器了，那么为什么还需要再使用解释器来“拖累”程序的执行性能呢?比如JRockit VM内部就不包含解释器.字节碟全部都依靠即时编译器编译后执行。**
    * 当程序启动后，解释器可以马上发挥作用，省去编译的时间，立即执行。
    * 编译器要想发挥作用，把代码编译成本地代码，需要一定的执行时间。但编译为本地代码后，执行效率高。
    * **尽管JRockit VM中程序的执行性能会非常高效，但程序在启动时必然需要花费更长的时间来进行编译。对于服务端应用来说，启动时间并非是关注重点，但对于那些看中启动时间的应用场景而言，或许就需要采用解释器与即时编译器并存的架构来换取一个平衡点。**在此模式下，当Java虚拟器启动时，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成后再执行，这样可以省去许多不必要的编译时间。随着时间的推移，编译器发挥作用，把越来越多的代码编译成本地代码，获得更高的执行效率。

##### 编译器

* 概念解释
  * Java语言的“编译期”其实是一段“不确定”的操作过程，因为它可能是指一个前端编译器（其实叫“编译器的前端”更准确一些）把 .java文件转变成.class文件的过程;
  * 也可能是指虚拟机的后端运行期编译器(JIT 编译器，Just In Time Compiler)把字节码转变成机器码的过程。
  * 还可能是指使用静态提前编译器(AOT 编译器，Ahead of Time Compiler）直接把.java文件编译成本地机器代码的过程。
  
* 热点代码及其优化

  * **一个被多次调用的方法，或者是一个方法体内部循环次数较多的循环体都可以被称之为“热点代码”，因此都可以通过JIT编译器编译为本地机器指令。由于这种编译方式发生在方法的执行过程中，因此也被称之为栈上替换，或简称为OSR (On StackReplacement）编译。**
  * 一个方法究竟要被调用多少次，或者一个循环体究竟需要执行多少次循环才可以达到这个标准?必然需要一个明确的阈值，JIT编译器才会将这些“热点代码”编译为本地机器指令执行。这里主要依靠热点探测功能。
  * ==**目前HotSpot vwM所采用的热点探测方式是基于计数器的热点探测。**==

* 采用基于计数器的热点探测，HotSpot VM将会为每一个方法都建立2个不同类型的计数器，分别为方法调用计数器（Invocation Counter）和回边计数器(BackEdge Counter) 。

  * 方法调用计数器用于统计方法的调用次数
  * 回边计数器则用于统计循环体执行的循环次数

* 这个计数器就用于统计方法被调用的次数，它的默认阈值在 client模式下是1500 次，在 server模式下是 10000次。超过这个阈值，就会触发JIT编译。

  * 这个阈值可以通过虚拟机参数-XXX:CompileThreshold来人为设定。

  <img src="%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%E5%92%8C%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B.assets/1705582483725.png" alt="1705582483725" style="zoom:50%;" />

  * 当一个方法被调用时，会先检查该方法是否存在被JIT编译过的版本，如果存在，则优先使用编译后的本地代码来执行。如果不存在已被编译过的版本，则将此方法的调用计数器值加1，然后判断方法调用计数器与回边计数器值之和是否超过方法调用计数器的阈值。如果已超过阈值，那么将会向即时编译器提交一个该方法的代码编译请求。

* 热度衰减
  * ==如果不做任何设置，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即一段时间之内方法被调用的次数。当超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被减少一半，这个过程称为方法调用计数器热度的衰减(Counter Decay)，而这段时间就称为此方法统计的半衰周期(counter Half Life Time)。==
  * 进行热度衰减的动作是在虚拟机进行垃圾收集时顺便进行的，可以使用虚拟机参数-XX:-UseCounterDecay来关闭热度衰减，让方法计数器统计方法调用的绝对次数，这样，只要系统运行时间足够长，绝大部分方法都会被编译成本地代码。
  * 另外，可以使用-XXX:CounterHalfLifeTime参数设置半衰周期的时间，单位是秒。



* 回边计数器
  * 它的作用是统计一个方法中循环体代码执行的次数，在字节码中遇到控制流向后跳转的指令称为“回边”(Back Edge）。显然，建立回边计数器统计的目的就是为了触发OSR编译。



* 缺省情况下HotSpot VM是采用解释器与即时编译器并存的架构，当然开发人员可以根据具体的应用场景，通过命令显式地为Java虚拟机指定在运行时到底是完全采用解释器执行，还是完全采用即时编译器执行。如下所示:

  * -Xint:完全采用解释器模式执行程序;

    ```CMD
    java -Xint -version
    ```

    ![1705583678410](%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%E5%92%8C%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B.assets/1705583678410.png)

  * -Xcomp:完全采用即时编译器模式执行程序。如果即时编译出现问题，解释器会介入执行。

    ![1705583731972](%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%E5%92%8C%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B.assets/1705583731972.png)

  * -Xmixed:采用解释器+即时编译器的混合模式共同执行程序。

    ```java
    /**
     * 测试解释器模式和JIT编译模式
     *  -Xint  : 6497ms
     *  -Xcomp : 949ms
     *  -Xmixed : 878ms
     */
    public class IntCompTest {
        public static void main(String[] args) {
    
            long start = System.currentTimeMillis();
    
            testPrimeNumber(1000000);
    
            long end = System.currentTimeMillis();
    
            System.out.println("花费的时间为：" + (end - start));
    
        }
    
        public static void testPrimeNumber(int count){
            for (int i = 0; i < count; i++) {
                //计算100以内的质数
                label:for(int j = 2;j <= 100;j++){
                    for(int k = 2;k <= Math.sqrt(j);k++){
                        if(j % k == 0){
                            continue label;
                        }
                    }
                    //System.out.println(j);
                }
    
            }
        }
    }
    ```

    

* HotSpot的JIT分类

  * 在HotSpot VM中内嵌有两个JIT编译器，分别为client Compiler和server Compiler，但大多数情况下我们简称为c1编译器和c2编译器。开发人员可以通过如下命令显式指定Java虚拟机在运行时到底使用哪一种即时编译器，如下所示:

  * -client:指定Java虚拟机运行在client模式下，并使用c1编译器;
    
  >C1编译器会对字节码进行简单和可靠的优化，耗时短。以达到更快的编译速度。
    
  * -server:指定Java虚拟机运行在server模式下，并使用C2编译器。

    > C2进行耗时较长的优化，以及激进优化。但优化的代码执行效率更高。

* C1和C2编译器不同的优化策略︰

  * 在不同的编译器上有不同的优化策略，c1编译器上主要有方法内联，去虚拟化、冗余消除。
    * **方法内联:将引用的函数代码编译到引用点处，这样可以减少栈帧的生成，减少参数传递以及跳转过程**
    * 去虚拟化:对唯一的实现类进行内联
    * 冗余消除:在运行期间把一些不会执行的代码折叠掉
  * **C2的优化主要是在全局层面，逃逸分析是优化的基础。**基于逃逸分析在c2上有如下几种优化:
    * 标量替换:用标量值代替聚合对象的属性值
    * 栈上分配:对于未逃逸的对象分配对象在栈而不是堆
    * 同步消除:清除同步操作，通常指synchronized
  * 分层编译(Tiered compilation）策略:程序解释执行（不开启性能监控）可以触发c1编译，将字节码编译成机器码，可以进行简单优化，也可以加上性能监控，C2编译会根据性能监控信息进行激进优化。
  * 不过在Java7版本之后，一旦开发人员在程序中显式指定命令“-server"时，默认将会开启分层编译策略，由c1编译器和c2编译器相互协作共同来执行编译任务。

  

  

* AOT编译器

  * jdk9引入了AOT编译器(静态提前编译器，Ahead of Time Compiler)
  * Java 9 引入了实验性AOT编译工具jaotc。它借助了Graal 编译器，将所输入的 Java类文件转换为机器码，并存放至生成的动态共享库之中。
  * **所谓AOT编译，是与即时编译相对立的一个概念。我们知道，即时编译指的是在程序的运行过程中，将字节码转换为可在硬件上直接运行的机器码，并部署至托管环境中的过程。而AOT 编译指的则是，在程序运行之前，便将字节码转换为机器码的过程。**
  * .java ——–> .class ———–> .so
  * 最大好处: Java虚拟机加载已经预编译成二进制库，可以直接执行。不必等待即时编译器的预热，减少Java应用给人带来“第一次运行慢”的不良体验。
  * 缺点：破坏了java"一次编译，到处运行”，必须为每个不同硬件、os编译对应的发行包。
    降低了Java链接过程的动态性，加载的代码在编译期就必须全部已知。还需要继续优化中，最初只支持Linux x64 java base

  

![1705585210089](%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%E5%92%8C%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B.assets/1705585210089.png) 