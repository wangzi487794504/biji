#### 动态链接

* 每个栈帧内部都包含一个指向运行时常量池中该栈帧方法得引用。
  * 包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接。比如invokedynamic
* 在Java源文件被编译到字节码文件中时，**所有的变量和方法引用都作为符号引用(symbolic Reference）保存在class文件的常量池里。**
  * 比如:描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么动态链接的作用就是为了将这些**符号引用转换为调用方法的直接引用。**



#### 方法调用

* 动态链接与方法息息相关（按照编译时能不能确定）
* 静态链接
  * 当一个字节码文件被装载进JVM内部时，**如果被调用的目标方法在编译期可知,且运行期保持不变时。这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接。**
* 动态链接
  * 如果被调用的方法在编译期无法被确定下来，也就是说，只能够在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此也就被称之为动态链接。
* 静态链接对应着早期绑定
  * 早期绑定就是指被调用的目标方法如果在编译期可知，且运行期保持不变时即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用。
* 动态链接对应着晚期绑定
  * 如果被调用的方法在编译期无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法，这种绑定方式也就被称之为晚期绑定。
* Java中任何一个普通的方法其实都具备虚函数的特征，它们相当于c++语言中的虚函数（C++中则需要使用关键字virtual来显式定义）。如果在Iava程序中不希望某个方法拥有虚函数的特征时，则可以使用关键字final来标记这个方法。
  * 非虚方法
    * 如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法。
    * 静态方法、私有方法、final方法、实例构造器、父类方法都是非虚方法。
    * 其他方法称为虚方法。
* 多态的使用前提：
  * 类的继承关系
  * 方法的重写
* 虚拟机中提供了以下几条方法调用指令：
  * 普通调用指令
    * invokestatic:调用静态方法，解析阶段确定唯一的方法版本
    * invokespecial:调用<init>方法、私有及父类方法，解析阶段确定唯一方法版本
    * invokevirtual：调用所有虚方法
    * invokeinterface: 调用接口方法
  * 动态调用指令
    * invokedynamic：动态解析出需要调用的方法，然后执行。java7增加了一个invokedynamic指令，这是java为了实现【动态语言类型】支持而做的一种改进。
    * 但是在Java7中并没有提供直接生成invokedynamic指令的方法，需要借助AsM这种底层字节码工具来产生invokedynamic指令。直到Java8的Lambda表达式的出现，invokedynamic指令的生成，在Java中才有了直接的生成方式。
  * 前四条指令固化在虚拟机内部，方法的调用执行不可人为干预，而invokedynamic指令则支持由用户确定方法版本。其中invokestatic指令和invokespecial指令调用的方法称为非虚方法,其余的(final修饰的除外)称为虚方法。

#### java语言重写的本质

* 找到操作数栈顶的第一个元素所执行的对象的实际类型，记作C。

* ==如果在类型c中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束;如果不通过，则返回  java.lang.illegalAccessError异常。==

* ==否则，按照继承关系从下往上依次对c的各个父类进行第2步的搜索和验证过程。==

* 如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常。

* illegalAccessError异常

  * 程序试图访问或修改一个属性或调用一个方法，这个属性或方法，你没有权限访问。一般的，这个会引起编译器异常。这个错误如果发生在运行时，就说明一个类发生了不兼容的改变。

* 在面向对象的编程中，会很频繁的使用到动态分派，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率。因此，为了提高性能，==JVM采用在类的方法区建立一个虚方法表(virtual method table）(非虚方法不会出现在表中)来实现。使用索引表来代替查找。==

  * 每个类中都有一个虚方法表，表中存放着各个方法的实际入口。
  * 那么虚方法表什么时候被创建?
    * 虚方法表会在类加载的链接阶段被创建并开始初始化，类的变量初始值准备完成之后，JVM会把该类的方法表也初始化完毕。

* 虚方法表

  <img src="%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84%E4%B9%8B%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88.assets/1703763523226.png" alt="1703763523226" style="zoom:50%;" />

* <img src="%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84%E4%B9%8B%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88.assets/1703763686981.png" alt="1703763686981" style="zoom:50%;" />





#### 方法返回地址

* 无论通过哪种方式退出，在方法退出后都返回到该方法被调用的值置。方法正常退出时，调用者的pc计数器的值作为返回地址，即调用该方法令的下一条指令的地址。而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。
* 在字节码指令中，返回指令包含ireturn(当返回值是boolean、byte、 char、short和int类型时使用）、lreturn（long）、freturn(float)、dreturn(double)以及areturn(引用对象)，另外还有一个return指令供声明为void的方法（用于实例初始化方法、类和接口的初始化方法使用。）





#### 本地方法栈

* 当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限。
* 本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区。它甚至可以直接使用本地处理器中的寄存器
* 直接从本地内存的堆中分配任意数量的内存。
* 他也有栈溢出和超内存异常
* 并不是所有的JVM都支持本地方法。因为Java虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。如果JVM产品不打算支持native方法，也可以无需实现本地方法栈。
* 在Hotspot JVM中，直接将本地方法栈和虚拟机栈合二为一。